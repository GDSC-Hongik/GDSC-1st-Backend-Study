# 자바와 절차적/구조적 프로그래밍 - 프로그래밍 언어로서의 JAVA
## 1. 자바 프로그램의 개발과 구동
기존의 언어들은 각 플랫폼마다 각기 다른 배포 방식이 필요했다. <br> 
이런 불편함을 해소하기 위해 **JAVA는 메모리 안에 가상의 컴퓨터를 만들게 되는데, 이를 JVM이라고 부른다.** <br>

이는 실제의 컴퓨터와 유사한 구조를 띄는데, `컴퓨터-OS-소프트웨어` 구조를 `JVM-JRE-JDK`를 통해 모방하였다.
1. JDK: Java Development Kit. 자바 개발 도구로 소프트웨어와 대응되는 개념이고, JRE를 포함하고 있다. 자바 소스 컴파일러인 javac.exe를 포함하고 있다. **컴파일러는 자바 코드를 자바 바이트 코드로 변환 시켜줍니다.** (자바 클래스 파일) 이는 다른 컴파일러가 하는 역할과 똑같습니다. **컴퓨터가 이해할 수 있도록, 하이 레벨언어를 어셈블리어로 컴파일 해주듯이 JVM이 이해할 수 있도록 자바 바이트 코드로 변환시켜 줍니다.**
2. JRE: Java Runtime Enviorment. 자바 실행 환경으로 OS에 대응한다. 가상의 컴퓨터인 JVM을 제어하는 역할을 하고, JVM을 포함하고 있다. 자바 프로그램 실행기인 java.exe를 포함하고 있다. **JVM이 구동되기 위한 기본 환경을 제공합니다. JRE에 의해 JVM은 바이트 코드를 이해합니다.** 또한 실제 운영체제에게 시스템 자원을 빌려오거나 반납하는 역할을 해줍니다.
3. JVM: Java Virtual Machine. 물리적인 하드웨어, 컴퓨터에 대응하는 요소로 가상의 컴퓨터이다. <br> JDK를 이용해 개발된 프로그램은 JRE에 의해 JVM 상에서 구동된다. 인터프린터를 포함한다.


이런 구현을 통해 Java는 어떤 플랫폼에서 프로그램을 작성하든, 프로그램이 구동되도록 해줄 수 있었다. <br> 이런 특성을 Write Once, Run Antwhere이라고 부르는데, 한번만 작성해주면, 어디서든 구동할 수 있다는 의미이다. 

## 2. 자바의 절차적/구조적 프로그래밍 요소
**절차적 프로그래밍**은 **goto를 사용하지 말자!**로 한줄 요약 할 수 있다. java는 애초에 어떤 변태가 사용할 시도조차 못 하도록 goto를 예약어로 지정해 두었다. <br>
악명 높은 goto는 어떤 라벨, 지점으로 제어 흐름을 전이 시키는 명령어로, 프로그램 언어들이 꾸준~히 지워내는 것을 시도했다. <br> 비구조적이므로 판독성이 저하되며, 이로 인해 프로그램의 질이 떨어진다. 또한 프로그램 유지보수가 난해해서 디버깅이 어려워진다. ㅠ <br>
goto는 논리적 프로그래밍 구성을 통해 사용을 피할 수 있기에 안 쓰는게 낫습니다. 그리고 java에서는 애초에 사용을 막아 두었습니다.

<br> <br>

**구조적 프로그래밍**은 **함수를 써라!**로 한줄 요약 할 수 있다. 지역변수를 활용하여 함수를 작성해서 논리를 함수 단위로 분리하자는 것이다. 이는 코드의 이해를 쉽게 해주고, 중복 작성을 줄여줍니다.

<br>

자바의 **메서드**안에서 이 제어문의 절차적 요소와 구조적인 요소를 모두 확인할 수 있습니다. 제어문은 메서드 안에서만 존재할 수 있고, 함수와 같은 역할을 하는 메서드는 클래스 안에서만 정의될 수 있기 떄문입니다. 객체지향성을 살린 언어에서의 함수를 **메서드**라고 부릅니다.  

## 3. T 메모리 구조
### 3.1 T메모리 구조
프로그램은 메모리를 코드 실행 영역과 데이터 저장 영역의 두 영역으로 나누어 이용한다.
![2  메모리 이용 방식](https://user-images.githubusercontent.com/71186266/192135523-b18f7c15-6618-43b5-931d-c04c19abaf11.png)
<br>

이 때, 데이터 저장 영역을 3가지 영역으로 나누어 사용하는데, 그 모습이 T자와 같아 **T 메모리 구조** 라고 불리운다. <br>
![2209251641 T메모리구조](https://user-images.githubusercontent.com/71186266/192135524-7864dbc3-74c8-4c93-982b-e842f47a53eb.png)


각 영역은 스테틱 영역, 스택 영역, 힙 영역의 세가지 영역으로 나뉘는데, 이해의 편이를 위해, 저자는 각 영역에 별명을 붙여 주었다.
- 스태틱 영역: **클래스**들의 놀이터
- 스택 영역: **메서드**들의 놀이터
- 힙 영역: **객체**들의 놀이터
<br>

1. **스태틱 영역** <br> JRE는 먼저, 프로그램 안에 main()메서드가 있는지 확인한다. 이후 프로그램 실행을 사전준비 하고, JVM을 부팅한다.  <br> 부팅된 JVM은 목적 파일을 받아 실행한다. 이후, **스태틱 영역에 java.lang 패키지를 올린다음, 개발자가 작성한 모든 클래스와 임포트 패키지를 스태틱 영역에 가져다 놓는다.** <br> 이 때문에 스태틱 영역이 `클래스들의 놀이터`로 불리우는 것이다. -> <U>이는 바로 아래 3.2의 A point 사진에서 확인해볼 수 있다.</U> static으로 선언한 전역변수도 스태틱 영역에 저장된다. <br>
2. **스택 영역** <br> 스택영역은 메서드의 놀이터라고 하였다. main메서드를 포함한 메서드들의 정보를 담은 stack frame이 생성되는 위치이다. class의 정의를 위한 중괄호를 제외한, **여는 중괄호를 만날 때마다, 새로운 스택 프레임이 할당된다.** 그리고 닫는 중괄호를 만나면 해당 스택프레임을 없앤다. <br> 현재 중괄호 안에서 다른 중괄호를 만나게 되면, 현재의 스택 프레임 안에 또 다른 스택 프레임을 생성한다. **안쪽의 스택 프레임은 바깥 쪽의 스택 프레임의 변수를 참조 가능하지만, 반대로 바깥쪽 스택프레임은 안쪽의 스택프레임에 간섭이 불가능하다.** 이는 어찌 보면 당연한데, 흐름상 안쪽 스택프레임이 생성되기 전에는 당연히 바깥 프레임에서 참조가 불가능하고, 안쪽 스택 프레임이 만들어진 이후에 참조하려면, 안쪽 스택 프레임이 반환된 이후나 흐름이 다시 바깥으로 넘어올 텐데, 그 때는 이미 안쪽 스택프레임이 사라진 상태이다. <U>이는 아래 3.2의 A~C point를 참고하라.</U> <br> <br> 다른 메서드를 호출한 경우엔, 현재 흐름의 프레임 밖에 또 하나의 스택 프레임이 만들어지고, 두 프레임은 서로 간섭이 불가능하다. <br>
3. **힙 영역**: 다음 단원들에서 설명이 이루어질 예정. (작성되면 링크 연결 예정)


### 3.2 T 메모리 분석 - 스택 프레임
아래와 같은 코드를 통해 T 메모리 안에서의 스택 프레임의 생성과 반환을 관찰하겠다.
```java
public class Main {
  static int share;

  public static void main(String[] args) {
    int i = 10;
    int k = 20;
    // A Point

    if(i == 10) {
      int m = k + 5;
      // B Point
      k = m;
    } else {
      int p = k + 10;
      k = p;
    }
    // C Point
    k = fun(i);
    // E Point
  }

  private static int fun(int k) {
    int result;
    k = 7;
    result = k;
    return result; // D Point
  }
}
```

- **A Point**
![2  Apoint](https://user-images.githubusercontent.com/71186266/192135527-f87c33d3-ee5b-4baa-88b7-7b1a8f002cd2.png)
위에서 언급한 대로, java.lang 패키지와 클래스 Main에 대한 정보들은 모두 **스태틱 영역**에 생성 된다. static 변수 share 또한 같다. <br> 그리고 main함수에 대한 스택 프레임이 **스택 영역**에 생성 된다.
<br> <br>

- **B Point**
![2  Bpoint](https://user-images.githubusercontent.com/71186266/192135531-6e462c45-0937-4810-b21d-8e332d24a0e2.png)
if문을 만나 main()스택 프레임 안에 if(true) 스택 프레임이 생성되었다. if문 안에서는 main()의 변수들의 참조가 가능하다.
<br> <br>

- **C Point**
![2  Cpoint](https://user-images.githubusercontent.com/71186266/192135533-3175bbdb-7d16-4b09-8866-61094c35e75e.png)
if문이 끝나고 스택 프레임이 반환된 모습
<br> <br>

- **D Point**
![2  Dpoint](https://user-images.githubusercontent.com/71186266/192135521-cb1bec06-1975-45c0-a55e-1363dba9fe58.png)
다른 함수를 호출하여 또 하나의 스택 프레임인 fun() 스택 프레임이 만들어졌다. 이 안에서의 변수 k는 밖인 main()에서의 k와 다른 것을 알 수 있다. 서로 간섭이 불가능하다. 반환값이 7로 정해짐을 확인했습니다.
<br> <br>

- **E Point**
![2  Epoint](https://user-images.githubusercontent.com/71186266/192135522-832ca602-cfdc-4dbf-b4b3-06438b660da9.png)
함수 호출이 전부 끝나 스택 프레임이 사라진 모습. fun() 반환값이 k에 들어간 것을 볼 수 있다.

## 3.3 멀티 스레드와 멀티 프로세스 - T 메모리 구조
멀티 스레드와 멀티 프로세스 방식은 T 메모리 구조가 어떻게 나타날까?
- **멀티 스레드**: **스택 영역**을 스레드 개수만큼 분할하여 이용한다
- **멀티 프로세스**: T 메모리 구조 자체를 여러개 만들어 사용한다.

**멀티 프로세스**는 T 메모리 구조 자체를 여러개 만들어서 사용하기 때문에, 메모리 사용량이 클 수 밖에 없다. 그 대신 T 메모리끼리 서로 침범할 수가 없어서 안전한 구조를 가지고 있다. <br>

**멀티 스레드는** T 메모리를 하나를 사용하고, 스태틱 영역과 힙 영역을 공유하기 때문에, 멀티 프로세스에 대비하여 메모리 사용량이 적고 효율적이다. <br> **하지만**, 스태틱 영역과 힙 영역을 공유하는 것이 결코 안전한 일은 아니다. 당연하게도 변수를 공유하면서 동기화 문제가 생길 수 있다. <br>