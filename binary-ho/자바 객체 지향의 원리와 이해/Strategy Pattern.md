# 5. Strategy Pattern

## 5.1 전략 패턴이란
Strategy Pattern은 전략을 쉽게 바꿀 수 있게 해주는 디자인 패턴이다. <br> 
여기서 `전략`이란, 어떤 목적을 달성하기 위해 일을 수행하는 방식, 비즈니스 규칙, 문제를 해결하는 알고리즘 등을 의미한다. <br> 
프로그램에서 전략을 실행할 때는 쉽게 전략을 바꿔야 할 필요가 있는 경우가 많이 발생한다.

- **Strategy**: 인터페이스나 추상 클래스로 외부에서 동일한 방식으로 알고리즘을 호출하는 방법을 명시
- **ConcreteStrategy**: Strategy Pattern에서 명시한 알고리즘은 실제로 구현한 클래스
- **Context**: 스트래티지 패턴을 이용하는 역할 수행! 필요에 따라 동적으로 구체적인 전략을 바꿀 수 있도록 Setter 메서드를 제공해야함!

그러니까 **상황에 따라 다양하게 전략을 바꿔야 하는 Context가 존재할 때 이를 어떻게 구현할지에 대한 패턴이다.** 상황에 따라 기능의 **변화**를 주려고, 매번 코드를 수정하려면 OCP에 위배된다. <br> 그리고 변화 외에 **추가**도 문제다. 새로운 전략을 추가하는 경우엔 어떤가? 하필 기존 전략에서 사용중인 메서드를 또 쓰고 싶을 떄는 어떻게 할까? 중복을 감안하고 코드를 복사할까? 중복 코드는 나중에 큰 문제를 발생시킨다. 아니면 또 다른 캡슐화를 진행할까? 전략이 많아지면 많아질 수록, 이는 정말 어려운 일이 될 것이다. <br> <br>

## 5.2 전략 패턴 문제상황 예시 - OCP
예를 들어 `불도마뱀형 주머니 괴물`을 설계한다고 생각해보자. <br> 이름은 `파이리`와 `리자몽`으로 하자. 둘다 불 도마뱀이지만, 파이리는 move()함수를 호출하면, 총총 달려가고, 리자몽은 훨훨 날아간다. <br> 그런데 이 때, 파이리를 날 수 있는 괴물로 바꿔줘야 한다면? 파이리의 코드를 수정해 줘야한다. (OCP 위반) 그리고 리자몽과 같은 역할을 하는 move()로 바뀌면서 코드가 겹칠 수도 있게 된다. 중복코드는 큰 문제를 야기할 수 있다. <br> 캡슐화를 진행할까? 좋다. 하지만 `리자드`라는 새로운 괴물을 추가하려고 한다면? 리자드는 걸을까..날까? 새로운 괴물이 추가될 수록 끊임없이 고통 받게 되는 것이다.

## 5.3 해결책 - 전략 패턴

이런 설계에서의 문제를 해결하려면 
1. **무엇이 변화되었는가**를 추적해야 한다. 
2. 이후 이것을 클래스로 캡슐화 해야한다.

**변화되는 것은 이동 방식과 공격 방식이다.** 가장 큰 문제는 메서드들의 변화-추가이다. 새로운 이동방식! 새로운 공격 방식!이 계속해서 추가될 것인데, 이를 **별다른 코드 변경 없이 쉽게 제공하고 싶은 것이다.**  <br>
**이렇게 해결해보자**

3. 변화되는 클래스를 은닉한다.
변화되는 이동방식 move()와 공격방식 attack()을 캡슐화 해버립니다. 

```java
public interface MovingStrategy() { void move() }
public interface AttackStrategy() { void attack() }

public Class 파이리Strategy implement MovingStratege {
  void move() {
    println("fly");
  }
}

...
```

## Reference
JAVA 객체지향 디자인 패턴 <정인상, 채흥석 저>