# 3. 자바와 객체 지향
## 1. 인간 지향, 객체 지향 - Object
기존의 절차적/구조적 프로그래밍은 우리가 컴퓨터에게 눈높이를 맞춰준 것이다. 함수를 도입해 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 생각은 프로그래밍을 편리하게 만들었다. 하지만 이는 우리가 세상을 인지하는 방식과는 맞지 않는다. <br> <br> 우리가 인지하는 세상은 수 많은 객체 **Object**들의 합으로 이루어져 있다. 인간도 수 많은 객체들의 합이고, 새도, 꽃도, 고양이도 전부 수 많은 객체로 이루어져 있으며, 그 자체로 객체이고, 이들이 전부 모여 객체인 세상을 만든다. <br> 우리가 사물을 인지하는 방식대로 프로그래밍 하는 인간 지향적인 방법론이 탄생했는데, 그것이 바로 객체 지향이다.. <br> <br>


사물을 분류하여 객체를 정의하고, 그들의 속성과(property), 행위(method)를 정의해줍니다. 이로써 직관적인 프로그래밍이 가능하다.

## 2. 객체 지향 4대 특성 - 캡! 상추다
**캡! 상추다!**
1. 캡슐화 - Encapsulation: 정보 은닉(information hidinh)
2. 상속 - ~~Inheritance~~: 재사용
3. 추상화 - Abstraction: 모델링
4. 다형성 - Polymorphism: 사용 편의

### 2.1 클래스와 객체의 관계
클래스는 분류고 객체는 실체이다. 붕어빵과 붕어빵 틀의 예시를 기억하는가. 나는 정말로 많이 들어본 예시이다. 하지만, 클래스를 붕어빵 틀로 비유하는건 잘못 되었다. <br>
`붕어빵틀 붕어빵 = new 붕어빵틀()`에서 붕어빵 틀을 새로 만들면 붕어빵인가? 이는 직관적이지 않고 잘못된 비유이다. <br>
단순하다 **클래스는 분류에 대한 개념이고, 객체는 그 실체이다.** 사람 클래스의 객체로 이진호가 있고, 강아지 클래스의 객체로 강형욱이 있다. 이것이 정확한 클래스와 객체의 관계이다

### 2.2 추상화: 모델링
```markdown
추상: 여러 가지 사물이나 개념에서 **공통되는 특성**이나 **속성** 따위를 **추출**하여 파악하는 작용
```
우리가 자주 사용하는 객체지향에서의 추상화는 실제 추상화의 **추상**과 같은 말이다. <br> 이집트의 벽화는 어떤가? 보이는 그대로의 실체를 그리는 것이 아니라, 대상이 가지는 속성의 특징들을 뽑아 분해/결합해서 그려냈다. <br> 우리가 아는 추상화와 같다. **객체 지향의 추상화는 곧 모델링이다.** <br> **추상화란, 구체적인 것을 분해해서 관찰자가 관심 있는 특성만! 가지고 재조합하는 것이다.** <br> <br> 인간을 보자. 학교에서 관리할 인간은 학생, 병원에서 관리할 인간은 환자이다. 인간의 모든 특성을 구현할 할 필요 없이 내가 필요한 요소들만 구현하면 되는 것이다. <br> 모델은 실제 사물을 정확히 복제하는 게 아니라, 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. **모델링은 실제 사물을 단순하게 묘사하는 것이다.**
- 추상화의 결과는 클래스이다. 추상화 = 모델링 = class 키워드

### 2.3 객체
객체 지향의 4대 특성은 **클래스와 객체를 통해 구현된다.** <br>
- **객체란 세상에 존재하는 유일무이한 사물이다.** 객체는 속성과 기능을 가지고 있다. 객체의 특성을 속성이라고 하고, 기능/행위를 메서드라고 한다.<br>
- **클래스란 분류, 집합 등 같은 속성과 기능을 가진 객체를 총칭하는 개념이다.**
- 세상에 존재하는 유일무이한 객체(인스턴스)를 속성과 기능에 따라 분류해 보니, 객체를 통칭할 수 있는 클래스라는 개념이 나오게 됩니다.
- 객체가 가진 모든 특성이나 기능을 구현할 필요가 없다. **추상화는 구체적인 것을 분해해서 관심 영역(애플리케이션 경계, Application Boundary)에 대한 특성만을 가지고 재조합하는 것이다. = 모델링** 


### 2.4 추상화와 T 메모리
책에 나오는 예제를 이용하여, 추상화와 T 메모리에 대해 알아보겠습니다. <br>

| 객체명 |                                        미키마우스                                        |                                        제리                                        |
| :----: | :--------------------------------------------------------------------------------------: | :--------------------------------------------------------------------------------: |
| 속성들 | 이름: 미키마우스 <br>국적: 미국 <br>나이: 87 <br>종교: 무교 <br>신장: 70cm <br> ... <br> | 이름: 제리 <br>국적: 미국 <br>나이: 75 <br>종교: 기독교 <br>친구: 톰 <br> ... <br> |
|  행위  |                               달리다(), 먹다(), 울다() ...                               |                               달리다(), 먹다(), ...                                |

위와 같이 각 개체들의 특성을 정리한 다음, **공통 특성**을 뽑아냅니다. 추상화를 통해 어플리케이션 경계 내에서 관심 있는 특성들만 쏙쏙 뽑아 옵니다. 쥐 클래스 모델링-추상화의 결과는 아래와 같습니다.

|     쥐 클래스의 논리적 설계     |                쥐 클래스의 물리적 설계                 |
| :-----------------------------: | :----------------------------------------------------: |
|             **쥐**              |                       **Mouse**                        |
| 성명 <br> 나이 <br> 꼬리수 <br> | + name: String <br> + age: int <br> + countOfTail: int |
|             울다()              |                     + sing(): void                     |

물리적 설계는 논리적 설계를 개발 환경에 맞춘 설계입니다.

<br>

#### 3.5 코드와 함께 T 메모리 변화 관찰하기
이제, 위의 설계를 기반으로 직접 코드를 작성하고, 코드의 진행에 따른 T 메모리의 변화를 관찰하겠습니다.
```java
public class Mouse {
  public String name;
  public int age;
  public static int countOfTail = 1;

  public void sing() {
      System.out.println(name + "찍찍~");
  }
}
```
```java
public class Main {
  public static void main(String[] args) {
    Mouse micky = new Mouse();  // A, B, C Point
    micky.name = "미키";
    micky.age = 85;
    micky.sing();

    // D point
    micky = null;
    // E point
  }
}
```
`Mouse micky = new Mouse();`가 실행되는 과정을
`Mouse mickey`, `new Mouse()`, `=`의 세 가지 부분으로 나누어 설명하겠습니다. 각 연산이 일어나는 순간을 A ~ C Point로 표현했습니다. 

- **A point `Mouse mickey`**: **Mouse 객체에 대한 참조 변수 mickey를 만든다.** <br> `countOfTail`과 같은 static 맴버 변수는 그림과 같이 Mouse Class가 스태틱 영역에 등록될 때, 그 값까지 함께 등록되고, <br> `name`, `age`와 같은 일반 맴버 변수들은 변수 저장 공간이 따로 할당되지 않습니다. ![3  A point](https://user-images.githubusercontent.com/71186266/192167004-29ca89ab-b2ba-4aa5-83b2-3aa701a92523.png)
- **B Point `new Mouse()`**: Mouse 클래스의 **인스턴스**를 하나 만들어 **힙에 배치한다.** 이 떄, 맴버 속성 `name`, `age`를 위한 저장 공간이 인스턴스 안에 할당됩니다. (아직 연결하지 않은 상태) <br> ![3  B point](https://user-images.githubusercontent.com/71186266/192167005-bdef525b-b0d5-4f25-a692-cdd3405624cb.png)
- **C Point `=`**: Mouse 객체에 대한 주소(포인터)를 참조 변수 mickey에 할당한다. <br> ![3  C point](https://user-images.githubusercontent.com/71186266/192167006-3e3f911c-0627-4cf4-8f8f-f020ed4d34a0.png)

객체 속성은 힙 영역에 객체가 생성되면 그 때 각 객체 안에 맴버 속성을 위한 메모리 공간이 할당되고, static이 붙은 정적 속성의 경우에 T 메모리의 스태틱 영억에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보된다.

<br>

- **D point**: 객체 참조 변수 micky와 참조 연산자를 이용해, 힙 상의 실제 객체에 접근하여, 속성들에 값들을 할당해 주고 있다. <br> ![3  D point](https://user-images.githubusercontent.com/71186266/192167007-3852a8f0-fcd0-415c-b4ab-0638a9182985.png)

- **E Point**: null을 할당 해 준 상태. 이제 힙 영역의 :Mouse 객체를 참조하지 않는다. (연결 끊어짐) 이후 해당 객체는 가비지 컬렉터에 의해 메모리가 반환될 예정이다. <br> ![3  E point](https://user-images.githubusercontent.com/71186266/192167008-39b888af-89f4-4847-b0c2-2c0d0641a5f4.png)

실제 클래스와 인스턴스를 생성하는 코드를 통해 T 메모리의 변화를 관찰하였다.

|     이름      |                  다른 이름                  | 사는 곳(T 메모리) |
| :-----------: | :-----------------------------------------: | :---------------: |
|  static 변수  | 클래스[멤버] 속성 <br> 정적 변수, 정적 속성 |    스태틱 영역    |
|  local 변수   |                  지역 변수                  |     스택 영역     |
| 인스턴스 변수 |         객체[멤버] 속성, 객체 변수          |      힙 영역      |