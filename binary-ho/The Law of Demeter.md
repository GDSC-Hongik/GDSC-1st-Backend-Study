# Law of Demeter

<!-- 디미터 법칙은 `묻지 말고 시켜라` 스타일로도 알려져 있다. (엄밀하게 같은 것은 아님) <br> -->

디미터 법칙은 객체를 자율성을 높혀 직접 협력하도록 만드는 것이 목적이다. 이를 통해 객체의 정보의 은닉성이 높아지고 (캡슐화 보장), 다른 객체와의 결합도가 낮아진다.  <br>

자율적이라는 말이 무슨 의미일까? 또, 코드로는 어떻게 구현될까? 이에 대해 설명하기 전에 메시지 개념에 대해 이야기하겠다.  <br>


## 1. 메시지 개념
디미터 법칙을 설명하기 전에 메시지 개념에 대해서 설명하겠다. <br>

객체지향의 핵심은 상속 관계로 부터 나온다는 말이 있다. 그러나 객체지향의 핵심을 메시지로 보는 시선도 있다. <br>
객체가 어떤 행동을 하는 유일한 이유는 바로 **다른 객체의 요청을 받았기 때문이다.** <br> 
각 객체가 주고 받는 요청을 **메시지라고 부르고,** 메시지는 객체들이 서로 협력하기 위해 사용할 수 있는 유일한 소통수단이다.
<br>
<!-- 
책임-주도 설계는 객체가 아니라, 객체들이 주고 받는 메시지에 초점을 맞춘다. 설계를 할 때, 내가 어떤 객체가 필요한지를 먼저 생각하지 말고, **어떤 메시지가 필요한지를 먼저 고민하라는 것이다.** <br>
 -->


매시지는 메시지 이름과, 메시지 인자로 나우어져 있다. 어떤 사건의 증인으로 재판에 참여한 모자 장수가 있다고 하자. 재판장은 모자 장수에게 `증언하라`라고 요구할 것이다. 이것이 메시지 이름이 되고, `어제 매장에서 있었던 일을 증언하라`라고 말 한다면, `어제, 왕국`과 같은 내용들이 메시지 인자가 된다.

<br>

인터페이스는 어떤 객체가 수신할 수 있는 메시지의 목록이라고 볼 수 있다. <br>

메시지의 송신자가 되는 객체는 수신자가 메시지에 대해 반응할 것이라고만 어렴풋이 알면 되고, 메시지에 대한 세세한 반응은 전부 수신자 객체가 결정해야한다! <br>

## 2. 객체의 자율성

`이진호 너 어제 어디 있었어`. 이런 질문은 `what`만 있기 때문에, **어떻게** 표현할지는 수신자인 이진호가 정할 수 있다. 이런 경우 객체는 자율성이 있다. <br>
이런 질문에는 `집`과 같이 답변을 수신자가 정할 수 있다. <br> 

그럼 이러한 질문을 보자. `이진호 너 어제 언제 어디서 누구랑 있었는지 아침 부터 밤까지 시간 순서대로 세세하게 말 해봐`와 같은 질문은 what 뿐만 아니라 시간 순서대로 세세하게 말 해야한다는 **how의 제한이 있다.** `어떻게`가 들어가 마자 수신자의 선택은 크게 제한된다. <br>
수신자는 시간 순서대로 세세하게 말 하면서 자신의 데이터도 지키지를 못 한다. <br> 
따라서, 객체의 자율성을 존중하기 위해선, 메시지를 `What`까지만 요구하고, 내부 처리는 객체에게 맡겨야 한다. <br>

자율적인 객체는 자신의 데이터를 어떻게 공개할지 자신이 결정한다. 객체가 원한다면, **다른 객체가 어떠한 자료를 갖고 있는지 속사정을 몰라야 한다**. 함부로 까볼 수 없게 해야한다. **디미터 법칙이 다소 모호하게 느껴지는데, 실제로 객체를 구현할 때는 이 점을 유의하면 된다.** <br>

이렇게 객체에 자율성을 주면 객체는 내부와 외부가 분리된다. 상대 객체는 다른 객체의 외부 인터페이스만 알고, 내부 구현은 알지 못 한다. <br> 

## 3. 디미터 법칙을 어긴 예시
디미터 법칙에선 객체의 자율성을 강조했다. 이는 코드로 어떻게 나타날까?
```java
public Mono<Void> deletePost(final DeletePostCommand command) {
  return postRepository.findByPostId(command.getPostId())
        .switchIfEmpty(Mono.error(new PostNotFoundException()))
        .flatMap(post -> {
            if (!post.getUser().getId().equals(command.getDeleter().getUserId())) {
                return Mono.error(new AccessDeniedException());
            }
            return postRepository.save(post.deleteAndCopy());
          })
          .then();
}

```
여기서 이 부분만 떼어 보자

```java
if (!post.getUser().getId().equals(command.getDeleter().getUserId())) {
      return Mono.error(new AccessDeniedException());
}
```
post에서 getUser를 통해 유저 객체를 가져온 다음, getId()를 통해 유저의 id를 가져왔다. 이후 커맨드에서 getDleter()를 통해 딜리터를 가져오고 또 getUserId를 통해 아이디를 가져왔다. <br>

이는 `deletePost` 메소드가 `user` 객체와 `deleter`객체의 자율성을 개무시한 것이다. 이 두 객체가 사람이라고 생각해보자. 그냥 id를 담고 다니는 통 정도로 취급해서 아이디를 직접 빼낸 다음 내가 사용한 것이다. <br>

이렇게 하기보다는 
```java
public Mono<Void> deletePost(final DeletePostCommand command) {
  return postRepository.findByPostId(command.getPostId())
      .switchIfEmpty(Mono.error(new PostNotFoundException()))
      .flatMap(post -> postRepository.save(post.deleteAndCopy(command.getDeleter())))
      .then();
}
```
이렇게 하라는 것이다.
```java
.flatMap(post -> postRepository.deleteAndCopy(command.getDeleter()))
```
따로 떼어낸 if문이 이렇게 변했다. 이전과 달리 메소드
레포지토리는 여러 객체를 깊이 탐색하지 않고, 포스트가 직접 deleteAndCopy()메소드를 수행하면서, post 삭제 권한을 체크하는 것이다. <br>


### 더 간단한 예시
더 간단한 예시를 보자.
```java
@Service
public class NotificationService {

    public void sendMessageForSeoulUser(final User user) {
        if("서울".equals(user.getAddress().getRegion())) {
            sendNotification(user);
        }
    }
}
```
서울의 사는 유저를 발견할 경우 if문이 true가 되는 코드다. <br>
유저는 Address 객체를 내부적으로 가지고 있고, Address 객체는 내부적으로  Region 객체를 가지고 있다. <br>

코드는 sendMessageForSeoulUser 메소드가 user를 가져와서, 그 안의 address 객체를 가져와서, 그 안의 region을 가져온 다음 비교한다. <br>
객체 user한테 메시지를 보내야하는데, 객체 user의 데이터를 까보고, 또 그 안의 객체를 까 보는 행위를 하고 있다. <br>

user는 자율성이 굉장히 무시당하고 있다. 메소드가 user의 데이터를 까보는 것 뿐만 아니라 그 안의 Address 객체까지 까 보고 있다. <br>

따라서, 아래와 같은 수정이 필요하다.
```java
public class Address {

    private String region;
    private String details;

    public boolean isSeoulRegion() {
        return "서울".equals(region);
    }
}

public class User {

    private String email;
    private String name;
    private Address address;

    public boolean isSeoulUser() {
        return address.isSeoulRegion();
    }
}
```
Address에 `isSeoulRegion()`과 User에 `isSeoulUser()`를 추가해 줌으로써, 객체가 데이터를 전부 공개하지 않도록 해주었다. **이제 메소드가 물어볼 수 있는 것은 그저 서울에 살고 있니? 뿐이다.**


## 4. 실질적인 구현 - Don't Talk to Stranger
실질적인 구현은 **객체들의 협력 경로를 줄이면서 진행한다.**

객체를 파고 드는 점을 하나로 제한한다고도 표현한다. 무슨 의미일까.

<br>

```java
@Service
public class NotificationService {

    public void sendMessageForSeoulUser(final User user) {
        if("서울".equals(user.getAddress().getRegion())) {
            sendNotification(user);
        }
    }
}
```
아까 보인 예제를 다시 보자. 메소드 `sendMessageForSeoulUser()`는 user 객체의 address 객체의 region 필드를 꺼내고 있다. 아주 멀리 있는 객체의 필드를 꺼내고 있는 것이다. 이런 설계를 피하자는 것이다. 앞서 언급한 방식으로 고치면 이런 설계를 피할 수 있다. <br>

getter가 줄줄이 이어져 **낯선,** **멀리있는** 객체를 건들지 않자는 의미로 `Don’t Talk to Strangers` 혹은 `Principle of least knowledge` 등의 규칙으로 불리고 있다.  <br>

구체적으로는 어떻게 구현하라는 것일까? <br>
디미터 법칙의 실질적 구현은 아래와 같은 규칙을 따르면 된다.

### 노출 범위를 제한하기 위해, 객체의 모든 메서드는 다음에 해당하는 객체와 메서드만 호출할 수 있다.
### 1. 객체 자신의 것들
### 2. 메서드의 파라미터로 넘어온 객체들의 것들
### 3. 메서드 내부에서 생성, 초기화된 객체의 것들
### 4. 인스턴스 변수로 가지고 있는 객체가 소유한 것들

조금이라도 멀리 있는 것들을 웬만하면 건들지 말자는 것이다 <br> 
이러한 규칙들로 디미터 법칙을 지킬 수 있다.


## Reference
- 객체 지향의 사실과 오해
- [Hello, Hannah](https://prohannah.tistory.com/204)
- [망나니 개발자](https://mangkyu.tistory.com/147)
- [https://tecoble.techcourse.co.kr/post/2020-06-02-law-of-demeter/](https://tecoble.techcourse.co.kr/post/2020-06-02-law-of-demeter/)
<!-- 
작성중


명확한 책임과 역할을 지닌 참가자들이 협력에 참여해야한다. 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력해야한다.

자율적인 객체. 객체들은 애플리케이션의 기능을 구현히가 위해 협력하고, 협력 과정에서 맡은 바 책임을 다하기 위해 자율적으로 판단하고 행동한다.
스스로 정한 원칙에 따라 판단하고 행동하는 객체. 타인의 명령에 따라 판단하고 행동하는 객체는 자율적이지 않음.

<br>

객체가 어떤 행동을 하는 유일한 이유는 다른 객체로 부터 요청을 수신했기 때문임. <br>
요청을 처리하기 위해 객체가 수행하는 행동을 **책임** 이라고 한다. 
자율적인 객체란 스스로의 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체를 의미한다. 

적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다. 따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 애플리케이션의 품질을 결정한다.


## 자유로운 증언
증언하라, 와
1. 목격했던 장면을 떠올려라
2. 기억을 시간순서대로 재구성하라
3. 말로 간결하게 표현하라.

책임을 너무나도 제한한다. 반대로 너무 자유로워도 문제  `설명하라` 뭘? 너무 추상적이고 포ㄹ괄적이다.
협력은 참여 의도를 명확하게 설명할 수 있는 수준에서만 추상적이여야 한다. <br>
증언하라가 훌륭한 책임인 이유는 자율성을 보장할 만큼 충분히 추상적이며, 협력 의도를 또렷하게 표현할 수 있을 정도로 구체적임

## 어떻게가 아닌 '무엇'을
- 증언해라: `what`만 있다. 어떻게에 대한 내용은 없어서 자율적으로 선택할 수 있다. 참 좋다.


1. 목격했던 장면을 떠올려라
2. 기억을 시간순서대로 재구성하라
3. 말로 간결하게 표현하라.

어떻게가 너무 많이 설명되어있다. 책임의 수준에서 `어떻게`가 들어가니까 모자 장수의 선택은 크게 제한된다.

객체가 다른 객체에 접근할 수 있는 유일한 방법은 요청 뿐. 이 요청을 메세지라고 부른다. 메세지는 객체로 하여근 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법임.

## 3. 메세지와 메서드
### 메세지
메세지는 메세지 이름과 메세지 인자로 나뉨
`모자장수 증언하라(어제, 왕국)` -> 모자장수야(수신자) 어제 왕국(인자)에서 목격한 것을 증언하라(메세지 이름) <br>

왕은 모자장수가 처리를 할 수 있다는 막연한 사실만을 알 뿐 방법에는 관여하지 않는다. 객체의 내부와 외부는 메세지를 기준으로 분리된다. 
메세지는 외부의 누구나 볼 수 있는 공개된 영역에 존재하지만, 메세지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속함.

<br>

메세지는 객체들이 서로 협력하기 위해 사용할 수 있는 유일한 의사소통 수단임. 객체의 메세지 수신 가능은 객체가 메세지에 해당하는 책임을 수행할 수 있다는 것을 의미함. 처리 방법은 자율적으로 선택할 수 있다. 외부의 객체는 메세지만 볼 수 있다.

### 메서드
메세지를 처리하기 위해 내부적으로 선택하는 방법을 **메서드라고 부른다.** 메세지를 수신한 객체는 실행시간에 자유롭게 메서드를 선택할 수 있다. 이것이 일반 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나이다.

## 4. 다형성
이제 다형성을 이렇게 표현할 수 있다. **다형성이란 서로 다른 유형의 객체가 동일한 메세지에 대해 서로 다르게 반응하는 것을 의미한다.**

메세지는 **무엇이 실행될지만 명시한다.** 어떻게는 수신자가 결정할 수 있다. 메세지 처리에는 제약이 없음. 다형성을 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있음. 왕의 입장에서는 상대가 누구든 간에 **증언하고** 있으므로, 결과가 동일하다. 수신자를 구별할 필요가 없다. 수신자의 종류에는 관심이 없다. 이것이 다형성 <br>

송신자 입장에서 동일한 메세지를 처리할 수 있으면 협력안에서 대체 가능하다. 
<br>

다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로서 달성된다. 이를 통해 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다. 협력을 유연하게 만들 수 있다.

## 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실이 가지는 장점

1. **협력이 유연해진다.** 송신자는 수신자가 메세지를 이해한다면 누구라도 상관 없다. 수신자를 유연하게 변경할 수 있다.
2. **협력이 수행되는 방식을 확장할 수 있다.** 협력의 세부적인 수행 방식을 쉽게 수정할 수 있다. 관계가 느슨하기 때문에, 책임만 완수한다면 어떻게든 수용 가능하다. 동작 방식을 바꾸어도 협력 구조가 변하지 않는다.
3. **협력이 수행되는 방식을 재사용 할 수 있다** 송신자가 누구여도 협력을 재사용 할 수 있다.


## 송신자와 수신자를 약하게 연결하는 메세지

결국 메세지의 은혜! 메세지가 다형성을 지탱한다. 메시지는 송신자와 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만들어준다.

송신자는 오직 메세지만 바라본다. 수신자가 메시지를 이해하고 처리해줄 것이라는 사실만 아는 것으로 충분하다.

## 메세지를 따라라
객체지향의 핵심, 메세지
객체지향의 기본 개념은 책임을 수행하는 자율적인 객체 <br>

연쇄적으로 메세지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다. <br>

객체지향의 강력함의 핵심은 상속 관계가 아닌 메시지로 부터 나온다. 객체지향 애플리케이션은 클래스를 이용해 만들어지지만, 메세지를 통해 정의된다. 

데이터 중심의 설꼐는 객체의 자율성을 저해한다. 외부의 객체가 객체의 내부를 마음대로 주무를 수 있다면, 객체의 자율성이 저하된다. 

객체가 메세지를 선택하는 것이 아니라, 메시지가 객체를 선택해야한다. 메시지를 중심으로 협력을 설계해야 한다.

책임 주도 설계 - 기본 아이디어는 객체들 간에 주고 받는 메시지를 기반으로 적저랗ㄴ 역할과 책임, 협력을 발견하는 것이다.


## What/Who 사이클
책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에, 수행할 객체를 결정하는 것. 이를 What/Who 사이클이라고 부른다. 어떤 행위를 먼저? 누가? (어떤 행위가 바로 메시지) <br>

객체가 어떤 메세지를 수신하고 처리할 수 있느냐가 객체의 책임을 결정한다.

## 묻지말고 시켜라
디미터 법칙, 묻지말고 시켜라 스타일. <br>

책임-주도 설계는 객체가 아니라 객체들이 주고 받는 메시지에 초점을 맞춤으로서 객체지향의 장점을 극대화한다. What/Who 사이클은 어떤 객체가 필요한지를 생각하지 말고, 어떤 메시지가 필요한지를 먼저 고민하라고 조언한다. <br>

송신자는 메시지 결정 시점에서 어떤 객체가 메시지를 수신할 것인지 알 수 없기 때문에 당연히 메시지 송신자는 메시지를 수신할 객체 내부 상태를 볼 수 없다. 따라서, 메시지 중심의 설계는 메시지 수신자의 캡슐화를 증진시키고, 내부를 모르므로 느슨하게 결합된다. <br>


객체는 다른 객체의 상태를 묻지 말아야한다! 객체가 다른 객체의 상태를 묻느나든 것은 메시지를 전송하기 이전에 객체가 가져야 하는 상태에 관해 너무 많이 고민하고 있다는 증거다. 필요한 메시지를 전송하기만 하고 메시지를 수신하는 객체가 스스로 메시지의 처리 방법을 결정하게 하라.

<br>

결과적으로 묻지 말고 시켜라 스타일은 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기 때문에, 설계를 유연하게 만든다. <BR>


샌디 메츠: 뭊디 말고 시켜라 스타일이란 메시지가 어떻게 해야하는지를 지시하지 말고 무엇을 해야하는지를 요청하는 것이라고 설명한다. <br>
어떻게에서 무엇으로 전환하는 것은 인터페이스의 크기를 급격하게 감소시킨다. 이는 외부에서 해당 객체에 대해 의존성이 적어진 다는 것을 의미한다. 결과적으로 메시지 송신자와 수신자 간의 결합도가 낮아지기 때문에, 설꼐를 좀 더 유연하게 만들 여지가 많아지고, 의도 역시 명확해진다. 객체가 자신이 수신할 메시지를 결정하게 하지 말고, 메시지가 협력에 필요한 객체를 발견하게 해야한다. <Br> <Br>


## 인터페이스와 메시지
메시지가 인터페이스를 결정한다. 객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 **메시지 전송이다.** 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며, 객체가 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 빚는다.


1. 협력에 참여하는 객체의 책임은 자율적이여야 한다.
2. 자율성 - 자신의 의지와 판단력을 기반으로 객체 스스로 책임을 수행하는 방법을 결정할 수 있음.
3. 메시지 - 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 채워진다.
4. 객체가 책임을 수행하기 위해 외부로 부터 메시지를 받기 위한 통로 -> 인터페이스


외부에 공개된 인터페이스를 **공용 언터페이스** 숨겨진 실제 동작 부분을 **구현이라고 부른다** 객체는 행동을 가진다. 행동은 메시지를 수신했을 떄만 실행되는 메시지 처리 방법이다. **이를 메서드라고 부른다.** 메서드의 코드는 외부에 노출되지 않으므로, 구현 부분에 속한다.

즉, 객체의 외부와 내부를 분리하라는 것은 결국 객체의 공용 인터페이스와 구현을 명확하게 분리하라는 말과 동일하다.


## 캡슐화
1. 상태와 행위의 캡슐화: 객체는 상태와 행위의 조합이다. 객체는 스스로 자신의 상태를 변경하고, 외부에 응답할 수 있는 행동을 내부에 함께 보관한다. 객체는 상태와 행동을 하나의 단위로 묶는 자율적인 실체다. 이런 관점에서의 캡슐화를 **데이터 캡슐화라고 한다.** 

객체는 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야함 하는 행위만 골라 공용 인터페이스를 통해 노출한다. 따라서 데이터 캡슐화는 인터페이스와 구현을 분리하기 위한 전제조건이다. **객체가 자율적이기 위해서는 자기 자신의 상태를 스스로 관리할 수 있어야 하기 떄문에, 데이터 캡슐화는 자율적인 객체를 만들기 위한 전제조건이다.**

외부의 객체는 공용 인터페이스에만 의존해야 하고, 구현 세부 사항에 대해서는 직접적으로 의존해서는 안 된다. 


객체를 자율적인 존재로 바라보는 것은 결국 객체의 내부와 외부를 엄격하게 분리한다는 것을 의미한다. 객체는 자신의 의지에 따라 변경하고 조작할 수 있는 비밀을 가지고 있다. 이것은 객체의 내부다. 또 동시에 객체는 외부의 객체가 의지하고 접근할 수 있는 공용 인터페이스를 가진다. 이것은 객체의 외부다. 어떤 것도 동시에 객체의 내부와 외부에 포함될 수 없다.

## 책임의 자율성이 협력의 품질을 결정한다.

객체의 책임이 자율적일 수록 협력이 이해하기 쉬워지고, 유연하게 변경할 수 있게 된다. 결과적으로 채김이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.
 -->
