# 4주차 스터디 
## 서적 내용 정리

---
### AOP(Aspect Oriented Programming)

- 관점 지향 프로그래밍
- 로직을 기준으로 핵심 기능과 부가적인 기능을 나누어 모듈화 진행
  - 모듈화 : 어떤 공통된 로직이나 기능을 하나의 단위로 묶음
- 횡단 관심사(Crosscutting Concerns)
  - 소스 코드 상에서 다른 클래스에서도 공통적으로 사용하는 코드
  - `Aspect`를 이용하여 모듈화하여 비즈니스 로직에서 분리 후 재사용
- 주요 개념
  - `PointCut`: Aspect 적용 위치 지정자
    - `"execution(**..repository.*.*(..))"`
    - <br>최근 애플리케이션은 Layered Architecture 기반</br>
    - <br>각 Layer 별  or 2~3 Layers 통합한 PointCut 정의하여 재사용</br>
  - `JoinPoint`: 스프링 프레임워크가 관리하는 빈의 모든 메서드
    - (광의) Aspect 적용이 가능한 모든 지점
    - (협의) 호출된 객체의 메서드
    - `ProceddingJoinPoint joinPoint`
    - `@Around("execution(**..repository.*.*(..))")`가 PointCut 일 때
      - `userRepository.save()` 가 호출된 상태라면
      - JoinPoint -> userRepository 객체의 save()
        - JoinPoint Parameter 를 사용하면, 실행 시점에 호출된 매서드의 정보 확인 가능
  - `Aspect`: Advisor 집합체
  - `Advice`: PointCut 적용할 로직, 즉 메서드
  - `Advisor`: 1개의 Advice + 1개의 PointCut -> Aspect가 나와서 사실상 무쓸모
- 스프링 AOP 특징
  - 인터페이스 기반
  - 프록시 기반
    - 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 방식
    - `@Before`: 해당 메서드가 실행하기 전
    - `@After`: 해당 메서드가 실행된 후
    - `@Around`: 매서드 실행 전과 후(예외 발생 시에도 실행됨)
    - `@AfterThrowing`: 메소드에서 예외가 발생되면 실행
    - `@AfterReturning`: 메소드가 정상 종료될 때
  - 런타임 기반
    - 컴파일 타임 vs 런타임
    - 컴파일: 코드를 기계어로 바꾸는 것
    - 런타임: 기계어로 바꾼 코드를 실행
- DAO 실행 시간 측정 예제 코드
```java
@Slf4j
@Aspect // 이제 Aspect 사용하겠다
@Component // Bean 등록, 객체 생성과 의존성 주입을 스프링에 위임
public class MeasureTimeAspect {
    // repository 안에 적용, 물론 다른 레이어에도 적용 가능
    // repository 안의 객체의 메서드들은 빈으로 등록해줘야함 -> AOP 적용 대상이기 때문
    // proceed()의 리턴값은 Object
    @Around("execution(**..repository.*.*(..))")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        // before advice
        StopWatch sw = new StopWatch();
        sw.start(); // Start Time Check
        
        // 기준 이전 코드는 before
        Object result = joinPoint.proceed(); // 시점 중요
        // 기준 이후 코드는 after로 구분
        
        // after advice
        sw.stop(); // Stop Time Check
        Long total = sw.getTotalTimeMillis();
        
        // 어떤 클래스의 메서드를 측정했는지 joinPoint 객체 안에 담겨 있음
        String className = joinPoint.getTarget().getClass().getName();
        String methodName = joinPoint.getSignature().getName();
        String taskName = className + "." + methodName;
        
        // 실행시간 로그 남기기
        log.info("[ExecutionTime] : {}, {}(ms)", taskName, total)
       
        return result;
    }
}
```

- 실행시간 예시
![undefined](./img/4주차/실행시간.png)