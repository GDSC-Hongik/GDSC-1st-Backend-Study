1장: 사람을 사랑한 기술
=======================
* 하나의 목적 파일, 하나의 소스 기반
* 스프링은 객체 지향 기반
* 스프링의 근원적 요소 3가지 - IoC/DI, AOP, PSA


2장: 자바와 절차적/구조적 프로그래밍
===================================
자바 구동을 위한 도구
-------
* JDK: 자바로 소프트웨어를 개발하기 위한 도구
* JRE: 자바 실행 환경(= operating system)
* JVM(= java virtual machine): 하드웨어

프로그램이 메모리를 사용하는 방식
-----
* 코드 실행 영역과  데이터 저장 영역을 구분.
* OOP에서는 데이터 저장 영역을 다시 3가지로 분리.
* 데이터 저장 영역 = static + stack + heap, T메모리 구조

자바에 남은 절차적/구조적 프로그래밍의 유산
----------------
* goto문 (not used)
    * not used인 이유: goto문을 사용하면 프로그램에서 여기저기 왔다갔다 함
    * → 프로그램에 대한 깊은 이해가 필요한데, 간단한 일이 아님.

main() method
--------------
1. JRE가 JVM을 가동
2. static area에 java.lang import
3. main의 ‘{’에서 스택 프레임 할당
4. args 저장을 위한 공간을 확보
5. main의 ‘}’에서 스택 프레임 소멸

변수와 메모리 & 블록 구문 & 지역변수
----------
* main method 진입할 때 생긴 스택 프레임 안에 위치.
* 초기화하지 않으면, 이전 프로그램이 버리고 간 쓰레기 값이 나옴.
* if문에 진입한다면…?
    * main 스택 프레임 안에 if(true) 스택 프레임이 생김.
    * if문 안에서 변수를 선언한다면, if(ture) 스택 프레임 안에 저장됨.
* 지역변수 - 스택 영역
* 클래스 멤버변수 - 스태틱 영역
* 객체 멤버변수 - 힙 영역

method 스택 프레임
----
```java
public class Start4 {
	public static void main(String[] args) {
		int k = 5;
		int m;

		m = square(k);
	}

	private static int square(int k) {
		int result;
		k = 25;
		result = k;
		return result;
	}
}
```
* 위의 프로그램 실행시, 메모리의 스택 영역에 main() 스택 프레임말고 square() 스택 프레임이 하나 더 생김.
* 스택 프레임간에는 접근이 불가능하다.


전역변수
----
* 사용하지 않는 것을 추천
    * 길어진 코드 어딘가에서 전역 변수를 건드렸다가 문제가 발생한다면, 어디에서 발생한 문제인지 찾는 것도 일이됨.
    * 그럼 아예 쓰지마?
          * 파이값처럼 이미 고정되어, 읽기만 하는 용도라면 적극 활용.



멀티 프로세스 vs 멀티 스레드
---
멀티 프로세스: 다수의 T메모리 구조
* 절대 침범 불가한 영역.
* 메모리 사용량이 큼.

멀티 스레드: 스택 영역만 스레드 개수만큼 분할하여 사용

정리
---
결국 OOP란 절차적/구조적 프로그래밍의 진화된 버전이므로, 절차적/구조적 프로그래밍도 잘 알아야 함.

스태틱: 클래스의 공간

스택: method의 공간

힙: 객체들의 공간


3장: 자바와 객체 지향
=========
객체 지향 == 인간 지향
-----
기존의 구조적 프로그래밍 언어의 핵심 → 함수

- 논리적인 단위로 분할하여 이를 정복(= 블록화하여 작성)

현실 세계는 객체들의 합

- 따라서, 우리가 주변에서 사물을 인지하는 방식대로 프로그래밍하자

객체지향의 4대 특성
------------
1. 캡슐화
2. 상속
3. 추상화
4. 다형성

클래스는 분류에 대한 개념, 객체는 실체

추상화
----------
- 추상화란 공통 특성/ 공통 속성 추출
- 객체 지향의 추상화는 곧 모델링이다
- 클래스는 같은 특성을 가진 여러 객체를 총칭하는 집합의 개념
- 객체는 유일무이한 사물, “unique”
- 클래스의 변수: 속성 = 명사로 표현되는 특성
- 클래스의 method: 기능/행위 = 수행 절차 or 로직
- 클래스 모델을 표현하는 방법: UML 클래스 다이어그램→ 논리적 설계 → 코드로 물리적 설계

static 키워드
---------
같은 클래스의 객체들이 모두 같은 값을 가지고 있다면, 자료형 앞에 ‘static’을 추가하여 정적 변수로 만든다.
이는 T 메모리 구조의 static area에 단 하나의 저장공간을 가지고, 모든 객체들이 이를 공유한다.

상속
--------
* 상속은 계층, 조직의 개념이 아니다.
* 상위 클래스의 특성을 하위 클래스에서 상속하고 확장하여 사용할 수 있다는 의미이다.
* 결국, 상속이란 분류도의 개념이다.
* 그러니 부모 클래스 - 자식 클래스로 이해하는 것은 옳지 않음.
* 상/하, 슈퍼/서브 등의 개념이 상속에 더 가깝다.
* 흔히 상속을 ‘is a’관계로 표현한다.
* 상속은 ‘is a’ 보다는 ‘is a kind of’관계로 표현되는 것이 바람직하다.
* 정리하자면, 상속은
    * 상위 클래스의 특성을 재사용하고
    *  상위 클래스의 특성을 확장하고
    * is a kind of 관계를 만족시킨다.


다중 상속
---
자바는 다중 상속을 지원하지 않음.
상위 클래스의 method들이 중복되는 경우에 문제가 발생하기 때문에 다중 상속대신 인터페이스를 사용.

다형성
------
오버라이딩: 같은 메서드 이름. 같은 인자 목록으로 상위 클래스의 메서드를 재정의
오버로딩: 같은 메서드 이름. 다른 인자 목록으로 중복 정의

4장: 자바가 확장한 객체 지향
=========
abstract
------
추상→ 선언만 하고 구현은 안하는.

형식적으로 존재만하는 메서드 혹은 클래스.

final
----------
자바에는 const가  not used로 지정되어 있어서 사용이 불가능하다.

이를 대체하는 것이 final 키워드.

클래스 앞에 쓰이면, 상속을 허락하지 않고,

변수 앞에 쓰이면, 값의 변경을 불허한다.

메서드의 경우, 오버라이딩이 금지된다.

instanceof
----------
* 객체_참조_변수 instanceof 클래스명
* 객체가 클래스의 인스턴스인지에 대해 boolean type으로 반환한다.

package
---------
* namespace를 만들어주는 역할
* 다른 기능의 동일 이름 클래스를 만드는 경우 그 둘의 구분을 위함이다.
