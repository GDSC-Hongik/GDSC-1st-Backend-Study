#<01. 사람을 사랑한 기술>

- 자바 vs C : C언어는 작성한 소스를 다른 컴퓨터에서 실행하려면 소스, 각 기종별 컴파일러가 필요하지만, 자바는 오직 오브젝트 파일만 필요

- UML : 의사소통 도구, 표기방법론

- CBD(component Based Development) : 컴포넌트 기반 개발로, 애플리케이션을 통으로 개발하는 것이 아닌, 의미있는 단위로 구분하여 개발하고 결합하는 방법론

- SOA(Service Oriented Architecture) : 서비스 지향 구조, 개발자의 입장에서가 아닌 현실의 업무 기준으로 개발하자는 사상

#<02.자바와 절차적/구조적 프로그래밍>
-JDK(자바 개발 도구)로 개발된 프로그램은 JRE(자바 실행 환경)에 의해 가상 컴퓨터인 JVM(자바 가상 기계)상에서 구동  Write Once Run Anywhere -객체 지향 프로그래밍 안에는 절차적/구조적 프로그래밍이 메서드에 녹아있음

절차적(프로그램의 실행순서 중구난방 X ) / 구조적(함수를 사용하여 중복코드제거 및 논리 분할)

-함수 vs 메서드 : 거의 차이점이 없지만, 함수는 클래스나 객체와 아무 관계가 없지만, 메서드는 반드시 클래스 정의 안에 존재해야함

-T메모리 구조 : 스태틱영역(클래스&패키지), 스택영역(메서드), 힙(객체)

-변수와 메모리: 지역변수(스택영역), 클래스 멤버 변수(스태틱 영역), 객체멤버변수(힙)

-외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능  
-메서드들 사이에서 직접 서로의 지역변수에 접근할 수 있는가? : 불가능 (입력값과 반환값에 의해서만 메서드 사이에서 값이 전달 될 뿐이다. )  
-멀티스레드: 스택 영역을 스레드 개수만큼 분할해서 쓰는 것으로, 하나의 T 메모리만 사용하는데 스택영역만 분할 해서 사용하는 것.  
 멀티 프로세스 대비 메모리 적게 사용 -멀티 프로세스: 다수의 데이터 저장 영역을 갖는 구조 , 다수의 T메모리 갖는 구조로 이때 각 프로세스마다 각자의 T 메모리가 있고 서로 참조할 수 없다. 안전 But 메모리 사용량 큼

#<03.자바와 객체지향> -객체지향의 4대 특성 – 캡슐화(정보 은닉), 상속(재사용), 추상화(모델링), 다형성(사용 편의) -클래스는 분류에 대한 개념, 객체는 실체

##1.추상화(모델링)

- 구체적인 것을 분해해서 관찰자가 관심 있는 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것

- 객체 : 세상에 존재하는 유일무이한 사물로 속성과 기능을 갖고있음 (클래스의 인스턴스)

- 클래스: 분류, 집합 같은 속성과 기능을 가진 객체를 총칭하는 개념

  ###\*Mickey & Jerry
  -Mouse 클래스들이 T메모리의 스태틱 영역이 배치 But, 클래스 변수 저장공간이 없음  Mouse 클래스의 속성이 아닌 Mouse 객체에 대한 속성이므로, 객체가 생성되어야만 힙 영역에 할당됨

  Mouse mickey = new Mouse();

  : Mouse 객체에 대한 참조 변수 mickey가 만들어 졌으므로 스택 프레임 안에 mickey가 생성됨new Mouse(); 가 실행되며 힙에 Mouse 클래스의 인스턴스 생성됨  대입 연산자가 실행되며 방금 클래스의 인스턴스 주소가 스택 프레임속 mickey에 할당됨

  -클래스 멤버=static멤버=정적 멤버 vs 객체 멤버=인스턴스 멤버 : static 키워드가 붙어있으면 클래스 멤버 속성(클래스명.속성명 형식으로 접근) / 안붙어있으면 객체 멤버 속성 ( 객체참조변수.속성명 )

  cf. 지역변수=초기화 안하면 쓰레기값 가짐 / 클래스 속성, 객체 속성은 초기화 하지 않아도 정수형(0),부동소수점형(0.0),논리형(false),객체(null) -세가지 변수 유형 정리 : static변수( in 스태틱 영역) / 인스턴스 변수 (in 힙) / 지역변수 (in 스택)

##2.상속(재사용 + 확장 )

- 객체 지향에서의 상속 : 상위클래스의 특성을 하위 클래스에서 상속하고 그에 더해 필요한 특성을 추가, 확장 할 수 있다. 상위클래스로 갈수록 추상화, 일반화되고 하위클래스로 갈수록 구체화,특수화 된다.

  cf. 클래스명은 분류스럽게, 객체 참조 변수명은 유일무이한 사물처럼 작명!

  -상속 관계는 is a kind of 관계다. \*상속 정리 -객체 지향의 상속은 상위 클래스의 특성을 재사용 및 확장 하는 것이다. -객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

- 자바에는 다중상속이 없음 ( 득 < 실 ), 대신 인터페이스를 도입함  
  -인터페이스 : be able to 관계 만족, 클래스가 하는 기능을 구현하도록 강제하게 됨  
  -상위 클래스는 물려줄 특성이 풍성할수록 좋고(LSP), 인터페이스는 구현을 강제할 메서드가 적을수록 좋다(ISP).

  +public 추상 메서드와 public 정적 상수만 가질 수 있음

  ###\*Animal & Penguin & pingu -하위 클래스의 인스턴스(penguin)가 생성 될 때, 상위 클래스의 인스턴스(Animal)도 함께 생성됨

##3.다형성(사용편의성) -오버라이딩 : 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의  
-오버로딩 : 같은 메서드 이름, 같은 인자 목록으로 다수의 메서드를 중복 정의  
-상위 클래스 타입의 객체 참조 변수(pingu-animal)을 사용하더라도 하위 클래스(penguin)에서 오버라이딩한 메서드가 호출된다는 사실 기억

##4.캡슐화(정보은닉)  
 – private(-), [default](~), protected(#), public(+) -객체멤버에 대한 접근인가, 정적멤버에 대한 접근인가를 고려해줘야함!

-public: 모두가 접근 가능

-protected: 상속/ 같은 패키지 내의 클래스에서 접근 가능

-default: 같은 패키지 내의 클래스에서 접근 가능

-private: 본인만 접근 가능

\*상속을 받지 않았다면, 객체 멤버는 객체를 생성한 후, 객체 참조 변수를 이용해 접근해야함

\*정적 멤버는 클래스명.정적멤버(or 객체참조변수명.정적멤버) 형식으로 접근하는 것을 권장

Call By Value vs Call By Reference -기본 자료형 변수는 저장하고 있는 값을 그 값자체로 판단, 참조 변수는 저장하고 있는 값을 주소로 판단

#<4.자바가 확장한 객체 지향>  
-추상메서드: 선언부는 있는데 구현부가 없는 메서드/ 추상클래스: 추상 메서드를 하나 이상 갖고 있는 클래스 But, 추상 메서드 없이도 추상클래스 선언 가능  
-추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. new 클래스(); 불가능

-추상메서드는 하위 클래스에게 메서드의 구현 강제함 (오버라이딩 강제)

-추상 메서드를 포함하는 클래스는 반드시 추상 클래서여야 한다.

-생성자: 인자가 있는 생성자를 만들면, 자바는 기본 생성자를 만들어 주지 않는다.

-static블록: 클래스 생성 시의 실행 블록, 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될때, T메모리의 스태틱 영역에 로딩되고 이때 딱 한번 해당 클래스의 static 블록이 실행됨 최대한 늦게 사용함으로써 메모리 사용을 늦추기 위함임

-final 클래스: 상속 허락 X / final 변수: 변경불가능 / final 메서드 : 오버라이딩 금지

-instanceof :객체가 특정 클래스의 인스턴스인지 물어보는 연산자로, t/f  객체 참조 변수의 타입이 아닌 실제 객체의 타입으로 판단 -패키지는 네임스페이스를 만들어주는 공간  중복되는 이름의 충돌 피할 수 있음

-interface는 추상메서드와 정적 상수만 가질 수 있으므로, 메서드에 public&abstract, 속성에 public&static&final 붙이지 않아도 자동으로 붙여줌 But, 그래도 직접 붙이는게 좋다

-this : 객체가 자기 자신을 지칭할 때 쓰는 키워드

- 지역변수와 속성의 이름이 같은 경우: 지역변수 우선

객체 변수와 이름이 같은 지역변수가 있는 경우, this사용해야 객체 변수 사용가능

정적 변수와 이름이 같은 지역변수가 있는 경우, 클래스명을 접두사로 사용해야 정적변수 O

-super : 바로 위 상위 클래스의 인스턴스 지칭 (자바는 단일 상속이니까) cf. super.super X
