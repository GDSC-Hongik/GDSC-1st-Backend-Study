# 자바 객체지향의 원리와 이해

## 01 사람을 사랑한 기술

### 신기술은 이전 기술의 어깨를 딛고

- 신기술은 이전 기술을 바탕으로 생겨난다. 스프링이라는 기술은 왜 생긴 것일까?
- 스프링 이전의 기술들을 알면, 그 이유를 알 수 있을 것이다.

### 기계어에서 객체지향 프로그래밍 언어로

- 컴퓨터는 0과 1밖에 이해하지 못한다. 이것이 기계어다.
- 하지만 기계어는 인간이 이해하기 어렵다.
- 기계어 명령어를 인간이 이해하기 쉽vs도록 일상 용어(니모닉)으로 만든 것이 어셈블리어다.
- 어셈블리어를 기계어로 번역해주는 SW를 어셈블러라고 한다.
- 하지만 CPU마다 어셈블리어가 다르다. 이는 CPU마다 이진 데이터를 해석하는 방식, 즉 기계어가 다르고, 기계어에 대응되는 어셈블리어가 다르기 때문이다. 이러면 CPU마다 어셈블리어를 따로 배워야 한다.

- 수많은 언어를 거쳐 C언어가 나왔다.
- C를 통해 작성된 코드는, CPU가 다르더라도 해당 CPU에 맞는 컴파일러를 사용하면 잘 실행된다. CPU마다 언어를 따로 배울 필요가 없는 것이다.

> C 소스 코드 → 윈도우/맥용 컴파일러 → 목적 파일
> 

- 목적 파일(.obj)는 컴파일러/어셈블러가 컴파일 혹은 어셈블 하여 생성 하는 기계어의 모음이다.
- 이를 통해 우리는 같은 동작을 하는 코드를 CPU에 따라 다르게 작성할 필요가 없다.
- 또한, 인간의 언어 체계가 기계어와 1:1이 아닌 m:n 대응이 된다.
- 대개는 m>n이라서, 여러 줄의 기계어 코드를 더 짧은 C 코드로 표현할 수 있게 된 것이다.

- C는 구조적 프로그래밍을 통한 패러다임을 제시했다.
- C++ 역시 객체지향 프로그래밍을 가능하게 만들었다.
- 새로운 언어가 나오면서, 패러다임이 변한다.
- Java는 C++과 달리 완전한 객체지향을 가능하게 했다. 모든 것은 클래스에서 존재해야 한다.

- 또한, C#과 Java는 가상 머신을 지원한다. 가상 머신이 왜 편리할까?
- OS별로 다른 컴파일러를 구비할 필요 없이, 하나의 JRE만 설치하면 된다… JRE가 뭘까?
- 잘 이해가 가지 않는다. 일단 자바 가상 머신 (JVM)에 대해 알아보자.
    - 자바를 실행하기 위한 가상 기계
    - OS에 구애받지 않고, OS 위에서 Java를 실행시키는 가상 컴퓨터
    - 어떻게?
        - 자바 컴파일러는 자바 소스 파일(*.java)을 컴파일하여 자바 목적 파일, 즉 자바 바이트코드(*.class)로 변환한다.
            - 자바 바이트코드는 자바와 기계어 중간에 있다 할 수 있다.
        - 자바 바이트코드는 JRE(Java Runtime Environment) 위에서 동작한다.
            - JRE는 다시 자바 API와 JVM(자바 가상 머신)로 구성된다.
        - JVM은 자바 바이트코드를 각 OS에 맞는 기계어로 변환하여 실행하는 역할을 수행한다.
            - [JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가.](https://catsbi.oopy.io/df0df290-9188-45c1-b056-b8fe032d88ca)
            - [JVM Internal - Naver D2](https://d2.naver.com/helloworld/1230)
- 이렇듯 언어의 발전사를 보면서, 기술은 결국 편의를 위해 발전해왔음을 알 수 있다.

### 짧은 글, 긴 생각

- 방법론은 방법론일 뿐이다. 제품이 아니다. 방법론을 실현하는 것이 제품(언어)이다.
- 스프링은 개발 사상이자 제품이다. 객체지향이라는 개념은 c++이라는 제품으로 실현된다.
- 스프링이라는 제품은 어떤 개념을 실현하는가? 모호하다.

- 스프링은 OOP를 근간으로 한다. 그래서 스프링을 알기 위해선 객체지향을 알아야 한다.
- 스프링은 방대하지만, 세 가지를 근간으로 한다. IoC/DI, AOP, PSA이다.
- 검색해보면 제어의 역전/의존성 주입, 관점 지향 프로그래밍, portable한 서비스 추상화라고 한다.

- 이 셋을 잘 이해해보도록 하자.

## 02 자바와 절차적/구조적 프로그래밍

### 자바 프로그래밍 개발과 구동

- JDK - 자바 개발 도구 (개발 도구)
- JRE - 자바 실행 환경 (OS)
- JVM - 자바 가상 기계 (컴퓨터)

- JDK로 개발한 프로그램을 JRE로 JVM 위에서 돌린다고 생각하면 된다.
- JDK는 JRE를 포함하고 JRE는 JVM을 포함한다.
- 위에서 설명했던 내용을 다시 한번 확인해보자.
    - 자바 컴파일러는 자바 소스 코드(.java)를 자바 바이트코드(.class)로 변환한다.
    - 이렇게 만들어진 자바 바이트코드는 운영체제에 설치된 JVM에 의해 실행된다.
        - 즉, 자바 자체는 플랫폼에 종속적이지 않지만, JVM은 플랫폼에 종속적이다.
- 정리하자면 기존에는 각 운영체제마다의 컴파일러를 가지고 목적 파일을 각각 만들어줘야 했다면, 자바에서는 동일한 자바 컴파일러로 바이트코드를 만들고, 실행만 운영체제에 맞춰서 해주면 된다는 것! 이것을 가능하게 해주는 것이 JVM이다.
    - [https://coding-factory.tistory.com/827](https://coding-factory.tistory.com/827)

- 프로그램이 메모리를 사용하는 방식
    - 코드 실행 영역 + 데이터 저장 영역
        - 데이터 저장 영역 (앞으로 이걸 T 메모리 구조라 하자)
            - 스태틱 영역 - 클래스 관련
            - 스택 영역 - 메서드 관련
            - 힙 영역 - 객체 관련
- main() 메서드의 실행
    
    ```java
    public class Start {
    	public static void main(String[] args) {
    		System.out.println("Hello OOP!");
    	}
    }
    ```
    
    - JRE는 먼저 main() 메서드를 체크한다.
    - Start에서 main 메서드를 발견하면, JVM을 통해 프로그램 실행을 준비한다.
    - JVM은 목적 파일을 받아 목적 파일을 실행한다.
    - main 메서드 실행 전 JVM에서 수행하는 전처리 작업
        - 모든 자바 프로그램이 반드시 포함하는 java.lang 패키지를 스태틱 영역에 배치
        - 개발자가 작성한 클래스와 임포트 패키지를 스태틱에 배치.
    - main() 스택 프레임을 스택 영역에 할당한다.
        - 이는 메서드의 여는 중괄호를 만날 때 이루어진다.
        - 메서드 인자(들)의 변수 공간을 할당한다.
            - ex) main 메서드 인자 args
        - 닫는 중괄호를 만나면 스택 프레임이 소멸된다.
    - main 메서드가 끝나면 JRE는 JVM을 종료하고 JRE도 메모리 상에서 사라진다.
- 변수의 저장
    - 스택 프레임 안에서 이루어진다.
- 블록 스택 프레임
    - 분기문 등이 실행되면 스택 안에 추가로 스택을 할당한다.
- 지역 변수와 메모리
    - 클래스 멤버 변수는 스태틱 영역에 존재
        - JVM 종료 전까지 고정(static)
    - 외부 스택 프레임에서 내부 스택 프레임 변수 접근은 가능하나, 그 역은 불가
- 메서드 호출과 메모리
    - 다른 메서드를 호출하는 경우에는?
    - 다른 메서드의 지역 변수를 참조할 수 없다.
        - 메서드는 서로의 고유 공간이기 때문
        - 포인터가 존재하지 않기에 정확한 위치 확인 불가
    - 전역 변수 사용 가능하나, 사용하지 않는 것이 좋음
        - 다른 메서드에 의해 전역 변수가 변화하게 되면 일일히 추적하는 것이 어려움
        - 물론 읽기 전용 값 (상수)로 사용하는 것은 괜찮다
- 멀티 스레드 / 멀티 프로세스
    - 멀티 스레드 - 스태틱과 힙 공유, 스택 영역을 스레드 개수만큼 분할!
        - 메모리 적게 사용 가능
    - 멀티 프로세스 - 다수의 T 메모리로 분할!
        - 메모리 많이 사용하지만 서로 침범하지 않기에 안전
    - 쓰기 가능한 전역 변수 사용하면 스레드 세이프가 깨짐
        - synchronized 키워드로 스레드에 락을 걸 수 있지만 멀티 스레드 장점 없어짐

## 03 자바와 객체 지향

- 객체 지향은 우리가 세계를 인식하는 것처럼 프로그래밍 하기 위해 등장한 개념
- 인간은 사물을 분류(classify)하여 이해
- 각 존재는 어떠한 분류에 속하며, 분류 속 객체는 속성과 행위를 가짐

- 객체 지향의 4대 특성
    - 캡슐화 - 정보 은닉
    - 상속 - 재사용
    - 추상화 - 모델링
    - 다형성 - 사용 편의
- 클래스 vs 객체 - 붕어빵틀과 붕어빵 비유?
    - 코드 상에서는 이해하기 어려움…
    - 개념과 실체로 구별하는 것이 더 좋은 메타포
- 추상화는 모델링
    - 공통 속성/특성을 추출하여 묶어내는 것!
    - 단, ‘관심있는’ 특성/속성만 해당
    - 클래스를 이용하여 생성된 객체 = 인스턴스라는 표현으로 강조
    - 위에서 말한 ‘관심있는’ 의미는?
        - ‘내가 만들고자 하는 서비스에 따라 달라진다는 것
            - 같은 사람이더라도 병원 앱은 환자, 은행 앱은 고객…
        - 이걸 애플리케이션 경계, 혹은 컨텍스트라고 함
    - 정리하자면, 추상화는 ‘구체적인 것을 분해해서’ ‘관심 영역(== 애플리케이션 경계)에 있는 특성만’ 가지고 ‘재조합’ 하는 것!
    - 즉, 추성화는 모델링이다.
        - 모델은 실제 사물을 복제하는 것이 아니라 관심있는 부분만 추출해서 표현한 것
        - 백엔드의 경우 db 스키밍이 추상화라고 할 수 있음
- 클래스 멤버과 객체 멤버
    - static과 인스턴스 멤버!
    - 스태틱 멤버를 무엇으로 할 것인지?
        - 멤버들 간에 공유되는 속성
        - 그렇다면 행위는? ‘정적 메서드’. 객체 존재 여부와 관계없이 쓸 수 있도록…
            - main 메서드, getter, setter 정도를 정적 메서드로 쓸 수 있겠다
- 상속은 재사용과 확장
    - 상속은 추상화를 통해 모델링된 분류 관계의 확장
    - 추상화의 반대를 상속으로 봐야할까? 글쎄…
        - 추상화된 개념을 확장시켜 구체적인 개념으로 만들어내는 것이 확장
        - 완전히 반대라고 보기는 어려운 것이, 추상화는 모델링이고, 모델링 없이 확장 관계를 만들어낼 수는 없기 때문…
    - inheritence가 아닌 extends 키워드를 사용하는 맥락을 잘 체크하자!
    - 왜 재사용일까?
        - 상위 클래스에서 정의된 메서드를 하위 클래스에서 사용할 수 있다는 것
        - 하위 클래스에서 일일히 메서드를 정의할 필요가 없다!
        - 상속에서 재사용이 가능하다는 것은 이러한 의미