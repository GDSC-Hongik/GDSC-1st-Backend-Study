# 자바 객체지향의 원리와 이해

## 01 사람을 사랑한 기술

### 신기술은 이전 기술의 어깨를 딛고

- 신기술은 이전 기술을 바탕으로 생겨난다. 스프링이라는 기술은 왜 생긴 것일까?
- 스프링 이전의 기술들을 알면, 그 이유를 알 수 있을 것이다.

### 기계어에서 객체지향 프로그래밍 언어로

- 컴퓨터는 0과 1밖에 이해하지 못한다. 이것이 기계어다.
- 하지만 기계어는 인간이 이해하기 어렵다.
- 기계어 명령어를 인간이 이해하기 쉽도록 일상 용어(니모닉)으로 만든 것이 어셈블리어다.
- 어셈블리어를 기계어로 번역해주는 SW를 어셈블러라고 한다.
- 하지만 CPU마다 어셈블리어가 다르다. 이는 CPU마다 이진 데이터를 해석하는 방식, 즉 기계어가 다르고, 기계어에 대응되는 어셈블리어가 다르기 때문이다. 이러면 CPU마다 어셈블리어를 따로 배워야 한다.

- 수많은 언어를 거쳐 C언어가 나왔다.
- C를 통해 작성된 코드는, CPU가 다르더라도 해당 CPU에 맞는 컴파일러를 사용하면 잘 실행된다. CPU마다 언어를 따로 배울 필요가 없는 것이다.

> C 소스 코드 → 윈도우/맥용 컴파일러 → 목적 파일
> 

- 목적 파일(.obj)는 컴파일러/어셈블러가 컴파일 혹은 어셈블 하여 생성 하는 기계어의 모음이다.
- 이를 통해 우리는 같은 동작을 하는 코드를 CPU에 따라 다르게 작성할 필요가 없다.
- 또한, 인간의 언어 체계가 기계어와 1:1이 아닌 m:n 대응이 된다.
- 대개는 m>n이라서, 여러 줄의 기계어 코드를 더 짧은 C 코드로 표현할 수 있게 된 것이다.

- C는 구조적 프로그래밍을 통한 패러다임을 제시했다.
- C++ 역시 객체지향 프로그래밍을 가능하게 만들었다.
- 새로운 언어가 나오면서, 패러다임이 변한다.
- Java는 C++과 달리 완전한 객체지향을 가능하게 했다. 모든 것은 클래스에서 존재해야 한다.

- 또한, C#과 Java는 가상 머신을 지원한다. 가상 머신이 왜 편리할까?
- OS별로 다른 컴파일러를 구비할 필요 없이, 하나의 JRE만 설치하면 된다… JRE가 뭘까?
- 잘 이해가 가지 않는다. 일단 자바 가상 머신 (JVM)에 대해 알아보자.
    - 자바를 실행하기 위한 가상 기계
    - OS에 구애받지 않고, OS 위에서 Java를 실행시키는 가상 컴퓨터
    - 어떻게?
        - 자바 컴파일러는 자바 소스 파일(*.java)을 컴파일하여 자바 목적 파일, 즉 자바 바이트코드(*.class)로 변환한다.
            - 자바 바이트코드는 자바와 기계어 중간에 있다 할 수 있다.
        - 자바 바이트코드는 JRE(Java Runtime Environment) 위에서 동작한다.
            - JRE는 다시 자바 API와 JVM(자바 가상 머신)로 구성된다.
        - JVM은 자바 바이트코드를 각 OS에 맞는 기계어로 변환하여 실행하는 역할을 수행한다.
            - [JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가.](https://catsbi.oopy.io/df0df290-9188-45c1-b056-b8fe032d88ca)
            - [JVM Internal - Naver D2](https://d2.naver.com/helloworld/1230)
- 이렇듯 언어의 발전사를 보면서, 기술은 결국 편의를 위해 발전해왔음을 알 수 있다.

### 짧은 글, 긴 생각

- 방법론은 방법론일 뿐이다. 제품이 아니다. 방법론을 실현하는 것이 제품(언어)이다.
- 스프링은 개발 사상이자 제품이다. 객체지향이라는 개념은 c++이라는 제품으로 실현된다.
- 스프링이라는 제품은 어떤 개념을 실현하는가? 모호하다.

- 스프링은 OOP를 근간으로 한다. 그래서 스프링을 알기 위해선 객체지향을 알아야 한다.
- 스프링은 방대하지만, 세 가지를 근간으로 한다. IoC/DI, AOP, PSA이다.
- 검색해보면 제어의 역전/의존성 주입, 관점 지향 프로그래밍, portable한 서비스 추상화라고 한다.

- 이 셋을 잘 이해해보도록 하자.

## 02 자바와 절차적/구조적 프로그래밍

### 자바 프로그래밍 개발과 구동

- JDK - 자바 개발 도구 (개발 도구)
- JRE - 자바 실행 환경 (OS)
- JVM - 자바 가상 기계 (컴퓨터)

- JDK로 개발한 프로그램을 JRE로 JVM 위에서 돌린다고 생각하면 된다.
- JDK는 JRE를 포함하고 JRE는 JVM을 포함한다.
- 위에서 설명했던 내용을 다시 한번 확인해보자.
    - 자바 컴파일러는 자바 소스 코드(.java)를 자바 바이트코드(.class)로 변환한다.
    - 이렇게 만들어진 자바 바이트코드는 운영체제에 설치된 JVM에 의해 실행된다.
        - 즉, 자바 자체는 플랫폼에 종속적이지 않지만, JVM은 플랫폼에 종속적이다.
- 정리하자면 기존에는 각 운영체제마다의 컴파일러를 가지고 목적 파일을 각각 만들어줘야 했다면, 자바에서는 동일한 자바 컴파일러로 바이트코드를 만들고, 실행만 운영체제에 맞춰서 해주면 된다는 것! 이것을 가능하게 해주는 것이 JVM이다.
    - [https://coding-factory.tistory.com/827](https://coding-factory.tistory.com/827)

- 프로그램이 메모리를 사용하는 방식
    - 코드 실행 영역 + 데이터 저장 영역
        - 데이터 저장 영역 (앞으로 이걸 T 메모리 구조라 하자)
            - 스태틱 영역 - 클래스 관련
            - 스택 영역 - 메서드 관련
            - 힙 영역 - 객체 관련
- main() 메서드의 실행
    
    ```java
    public class Start {
    	public static void main(String[] args) {
    		System.out.println("Hello OOP!");
    	}
    }
    ```
    
    - JRE는 먼저 main() 메서드를 체크한다.
    - Start에서 main 메서드를 발견하면, JVM을 통해 프로그램 실행을 준비한다.
    - JVM은 목적 파일을 받아 목적 파일을 실행한다.
    - main 메서드 실행 전 JVM에서 수행하는 전처리 작업
        - 모든 자바 프로그램이 반드시 포함하는 java.lang 패키지를 스태틱 영역에 배치
        - 개발자가 작성한 클래스와 임포트 패키지를 스태틱에 배치.
    - main() 스택 프레임을 스택 영역에 할당한다.
        - 이는 메서드의 여는 중괄호를 만날 때 이루어진다.
        - 메서드 인자(들)의 변수 공간을 할당한다.
            - ex) main 메서드 인자 args
        - 닫는 중괄호를 만나면 스택 프레임이 소멸된다.
    - main 메서드가 끝나면 JRE는 JVM을 종료하고 JRE도 메모리 상에서 사라진다.
- 변수의 저장
    - 스택 프레임 안에서 이루어진다.
- 블록 스택 프레임
    - 분기문 등이 실행되면 스택 안에 추가로 스택을 할당한다.
- 지역 변수와 메모리
    - 클래스 멤버 변수는 스태틱 영역에 존재
        - JVM 종료 전까지 고정(static)
    - 외부 스택 프레임에서 내부 스택 프레임 변수 접근은 가능하나, 그 역은 불가
- 메서드 호출과 메모리
    - 다른 메서드를 호출하는 경우에는?
    - 다른 메서드의 지역 변수를 참조할 수 없다.
        - 메서드는 서로의 고유 공간이기 때문
        - 포인터가 존재하지 않기에 정확한 위치 확인 불가
    - 전역 변수 사용 가능하나, 사용하지 않는 것이 좋음
        - 다른 메서드에 의해 전역 변수가 변화하게 되면 일일히 추적하는 것이 어려움
        - 물론 읽기 전용 값 (상수)로 사용하는 것은 괜찮다
- 멀티 스레드 / 멀티 프로세스
    - 멀티 스레드 - 스태틱과 힙 공유, 스택 영역을 스레드 개수만큼 분할!
        - 메모리 적게 사용 가능
    - 멀티 프로세스 - 다수의 T 메모리로 분할!
        - 메모리 많이 사용하지만 서로 침범하지 않기에 안전
    - 쓰기 가능한 전역 변수 사용하면 스레드 세이프가 깨짐
        - synchronized 키워드로 스레드에 락을 걸 수 있지만 멀티 스레드 장점 없어짐

## 03 자바와 객체 지향

- 객체 지향은 우리가 세계를 인식하는 것처럼 프로그래밍 하기 위해 등장한 개념
- 인간은 사물을 분류(classify)하여 이해
- 각 존재는 어떠한 분류에 속하며, 분류 속 객체는 속성과 행위를 가짐

- 객체 지향의 4대 특성
    - 캡슐화 - 정보 은닉
    - 상속 - 재사용
    - 추상화 - 모델링
    - 다형성 - 사용 편의
- 클래스 vs 객체 - 붕어빵틀과 붕어빵 비유?
    - 코드 상에서는 이해하기 어려움…
    - 개념과 실체로 구별하는 것이 더 좋은 메타포
- 추상화는 모델링
    - 공통 속성/특성을 추출하여 묶어내는 것!
    - 단, ‘관심있는’ 특성/속성만 해당
    - 클래스를 이용하여 생성된 객체 = 인스턴스라는 표현으로 강조
    - 위에서 말한 ‘관심있는’ 의미는?
        - ‘내가 만들고자 하는 서비스에 따라 달라진다는 것
            - 같은 사람이더라도 병원 앱은 환자, 은행 앱은 고객…
        - 이걸 애플리케이션 경계, 혹은 컨텍스트라고 함
    - 정리하자면, 추상화는 ‘구체적인 것을 분해해서’ ‘관심 영역(== 애플리케이션 경계)에 있는 특성만’ 가지고 ‘재조합’ 하는 것!
    - 즉, 추성화는 모델링이다.
        - 모델은 실제 사물을 복제하는 것이 아니라 관심있는 부분만 추출해서 표현한 것
        - 백엔드의 경우 db 스키밍이 추상화라고 할 수 있음
- 클래스 멤버과 객체 멤버
    - static과 인스턴스 멤버!
    - 스태틱 멤버를 무엇으로 할 것인지?
        - 멤버들 간에 공유되는 속성
        - 그렇다면 행위는? ‘정적 메서드’. 객체 존재 여부와 관계없이 쓸 수 있도록…
            - main 메서드, getter, setter 정도를 정적 메서드로 쓸 수 있겠다
- 상속은 재사용과 확장
    - 상속은 추상화를 통해 모델링된 분류 관계의 확장
    - 추상화의 반대를 상속으로 봐야할까? 글쎄…
        - 추상화된 개념을 확장시켜 구체적인 개념으로 만들어내는 것이 확장
        - 완전히 반대라고 보기는 어려운 것이, 추상화는 모델링이고, 모델링 없이 확장 관계를 만들어낼 수는 없기 때문…
    - inheritence가 아닌 extends 키워드를 사용하는 맥락을 잘 체크하자!
    - 왜 재사용일까?
        - 상위 클래스에서 정의된 메서드를 하위 클래스에서 사용할 수 있다는 것
        - 하위 클래스에서 일일히 메서드를 정의할 필요가 없다!
        - 상속에서 재사용이 가능하다는 것은 이러한 의미
- is-a 관계?
    - is-a 관계는 클래스와 인스턴스의 관계로 오해될 소지가 있다.
    - 따라서 is-a-kind-of 관계를 쓰는 것이 좋다.
    - 이렇게 하면 하위 클래스 is a 상위 클래스라는 문장에서 오는 모호함을 없앨 수 있다.
        - 고래 is a kind of 동물
- 인터페이스 **
    - 다중 상속의 문제 해결하기 위해 포기. 대신 인터페이스 도입
    - 인터페이스 : 구현 클래스 is able to 인터페이스
    - **추상화가 ‘관심 있는’ 공통의 속성이나 기능을 묶어서 모델링하는 것이었다면, 인터페이스는 기능만을 추출해낸 것**
    - ‘이러이러한 기능’을 가져야 한다고 강제하는 명세 역할. 일종의 추상 클래스!
- 상속과 객체 참조 변수
    - 슈퍼클래스의 객체참조변수가 서브클래스의 인스턴스를 가리키는 것은 되는데, 그 반대는 안되는 이유?
        - ex) `Animal pororo = new Penguin();` (업캐스팅)
    - 상속이 아니라 확장으로 이해하면 쉽다. 서브클래스의 객체는 슈퍼클래스를 확장한 것이기 때문에 슈퍼클래스의 메서드와 변수를 포함한다. 그래서 슈퍼클래스의 참조변수가 접근하는 데 아무런 문제가 없다.
    - 만약 그 반대를 하고 싶다면, 명시적 형변환(casting)을 통해 서브클래스의 참조변수가 접근할 수 있는 변수와 메서드에 제한을 두면 된다.
        - [https://creator1022.tistory.com/110](https://creator1022.tistory.com/110)
- 다형성 - 오버라이딩과 오버로딩
    - 오버라이딩 (재정의)
        - 같은 메서드 이름, 인자 목록으로 상위 클래스 메서드 재정의
            - 재정의라 함은 하나의 메서드를 다르게 다르게 정의하여 사용하겠다는 것
    - 오버로딩 (중복정의)
        - 같은 메서드 이름, 다른 인자 목록으로 다수 메서드 중복 정의
            - 중복 정의라 함은 중복하여 정의된 것들을 (인자 다르게 하여) 모두 쓸 수 있다는 것
    - **슈퍼클래스의 참조변수를 통해 메서드를 호출하더라도 서브클래스의 오버라이딩된 메서드가 실행된다는 것을 알아두자!**
        - 왜일까? 동적 바인딩과 관련 있음

### 동적 바인딩과 오버라이딩

- 동적 바인딩이 뭔가? 실행 시간(런타임)에 어떤 메서드가 호출될 지 결정하는 것
    - 컴파일 타임에 결정할 수 있지 않나…? 라는 궁금증이 생길 수도 있다.
    - 우리가 보기에는 `Animal pingu = new Penguin();`과 `Animal pingu = new Animal();`은 분명히 다르기 때문…!
- 컴파일러가 Animal 참조 변수에 할당될 인스턴스가 실제로 어떤 값을 가질 것인지 고려하지 않는다. 왜일까?
    - 컴파일러는 실행하는 역할이 아니기 때문이다. 앞에서 자바 컴파일러는 자바 소스 코드(.java)를 자바 바이트코드(.class)로 변환하기만 하지, 실제 실행은 JVM을 통해 이루어진다.
    - 실행하지 않았다면, 인스턴스도 존재하지 않는다. 왜? 생성자가 호출된 적이 없기 때문에.
    - `Animal pingu = new Penguin();` 에서, Animal 참조 변수가 가리키는 인스턴스가 Penguin의 생성자로 만들어진 것인지 Animal의 생성자로 만들어진 것인지 컴파일 타임에서는 알 방도가 없다. 즉 객체의 타입이 확정되지 않은 상태이다.
    - 실행 시간 때야 비로소 생성자에 의해 인스턴스가 만들어지고, 이 인스턴스를 바탕으로 어떤 메서드를 호출할지 정해진다는 것. 이게 동적 바인딩이다.
- 컴파일 타임에서 컴파일러는 호출의 유효성만 검사한다.
    - 호출의 유효성만 검사한다는 것이 무슨 의미일까?
    - `Animal pingu` 의 `pingu.showName()` 을 컴파일할 때 컴파일러는 객체 참조 변수인 `pingu`의 타입인 `Animal` 과 관련해서 `showName()`에 대한 정보를 찾게 된다.
    - 앞에서 언급했듯이 참조변수 `pingu` 가 가리키는 인스턴스가 무엇인지는 신경쓰지 않는다. 컴파일러는 소스 코드를 실행하는 역할이 아니고 실행하지 않으면 생성자도 실행되지 않으며 이는 인스턴스에 대한 정보를 얻는 것이 불가능함을 의미한다.
    - 그래서 컴파일러는 `showName()` 에 대한 정보를 찾을 때 객체 참조 변수의 타입만을 고려한다는 것이고, Animal 클래스에서 `showName()` 메서드가 존재한다면 유효한 것이고 존재하지 않거나 Object 클래스에서도 찾을 수 없다면 컴파일 에러가 발생한다.
        - 이것은 슈퍼클래스의 참조변수가 서브클래스의 메서드를 사용할 수 없는 이유이기도 하다.
        - 컴파일 타임에서는 컴파일러가 슈퍼클래스 (혹은 슈퍼클래스를 상속해주는 클래스)의 컨텍스트에서 유효성(해당 메서드의 존재 여부)를 확인하기만 하고, 서브클래스의 생성자 역시 실행되지 않아 힙에는 참조변수가 가리키는 인스턴스 자체가 존재하지 않고, 따라서 컴파일러는 해당 메서드를 찾지 못했음을 알리는 컴파일 에러를 발생시키는 것
    - 런타임에서 결정하는 것은 어떤 메서드의 구현을 사용할 것인지임!
        - 이것을 **다이나믹 디스패치**라고 한다.
    

### 다이나믹 디스패치

- 런타임에서 어떤 메서드를 사용할 것인지 알기 위해서는 호출 객체가 어떤 것인지 확인해야 하고, 이를 바탕으로 오버라이드된 것을 찾아 해당 메서드를 호출한다.
- 따라서 소스 코드에서는 (심지어 바이트코드에서도) 이러한 과정이 드러나있지 않으며, 자바의 내부 동작 로직을 알아야 한다.
- 모든 메서드는 묵시적으로, 항상, `receiver parameter` 를 인자로 보낸다.
    
    > 리시버 파라미터는 인스턴스 메서드 혹은 내부 클래스 생성자를 위한 선택적인 구문 장치입니다. 
    
    인스턴스 메서드의 경우, 리시버 파라미터는 **메서드가 호출되는 객체**를 나타냅니다. 
    내부 클래스의 생성자의 경우, 리시버 파라미터는 새로 생성된 객체를 즉시 둘러싸는 인스턴스를 의미합니다. 
    
    어느 쪽이든 리시버 파라미터는 표현된 객체의 유형이 소스 코드에 표시되도록 하기 위해 홀로 존재하므로, 해당 타입은 어노테이션될 수 있습니다. ([https://stackoverflow.com/questions/24291091/why-can-we-use-this-as-an-instance-method-parameter](https://stackoverflow.com/questions/24291091/why-can-we-use-this-as-an-instance-method-parameter) 무슨 말인지 모르겠다면, 해당 링크 참고 : this를 통해 명시적으로 해당 메서드에 대한 어노테이션 가능하다는 말!)
    
    리시버 파라미터는 formal parameter(호출될 때가 아닌, 정의될 때 함수 안에서 사용되는 파라미터)가 아닙니다. 더 정확하게 말하자면, 어떠한 종류의 변수의 선언도 아니며, 메서드 호출 표현식이나 정규화된 클래스 인스턴스 표현에서 인수로 전달된 값에 구속되지 않으며, 실행 시 어떠한 영향도 미치지 않습니다.
    > 
    - [https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html) - 자바 공식 문서
- 리시버 파라미터를 명시적으로 사용하기 위해서는 `this` 를 사용하면 된다.
- `this` 를 사용하여 메서드 내부에서 호출 객체를 참조할 수 있다.
- 레퍼런스
    - [https://youtu.be/s-tXAHub6vg](https://youtu.be/s-tXAHub6vg) - 토비의 스프링 유튜브 : 다이나믹 디스패치
    - [https://alkhwa-113.tistory.com/entry/디스패치-다이나믹-디스패치-더블-디스패치](https://alkhwa-113.tistory.com/entry/%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B9%98-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B9%98-%EB%8D%94%EB%B8%94-%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B9%98)
    - [https://defacto-standard.tistory.com/entry/JAVA-Static-Method-Dispatch-Dynamic-Method-Dispatch-Double-Dispatch](https://defacto-standard.tistory.com/entry/JAVA-Static-Method-Dispatch-Dynamic-Method-Dispatch-Double-Dispatch)
    - [https://cyk0825.tistory.com/24?category=1164185](https://cyk0825.tistory.com/24?category=1164185)
    - [https://kjhoon0330.tistory.com/32](https://kjhoon0330.tistory.com/32)

### 다이나믹 디스패치의 원리는? : 가상 메서드 테이블

- 클래스는 스태틱 영역에 메모리를 할당받을 때 상속받은 모든 메서드 주소 + 자기 자신의 메서드 주소를 테이블로 저장한다. 이것이 가상 메서드 테이블(vtable)이다.
- 인스턴스가 생성될 때, 객체는 vtable의 주소를 저장한다.
- 이후 해당 객체는 vtable을 통해 메서드명을 찾아 호출한다. 이것을 바인딩이라 한다.
    - [https://lordofkangs.tistory.com/21](https://lordofkangs.tistory.com/21)

## 04 자바가 확장한 객체 지향

- abstract
    - 선언부만 있고 구현부 없음
    - 오버라이딩 강제. 일종의 명세 역할
    - 인스턴스 존재할 수 없음
- static 블록
    - 클래스가 스태틱 영역에 로딩될 때 실행
    - 프로그램 실행 시 X. 클래스 정적 속성 / 정적 메서드 / 인스턴스 사용 시 로딩
    - 사실 자주 쓰는 내용은 아님
- final
    - 클래스 - 상속 X
    - 변수 - const와 비슷. 읽기 전용
        - 정적 변수 - 선언/스태틱 블록 내부 초기화 가능
        - 객체 상수 -객체 생성자, 인스턴스 블록 초기화 가능
    - 메서드 - 오버라이딩 금지
- instanceof
    - 참/거짓 반환. 상속 관계 포함!
- package
    - namespace 역할
- interface - implements
    - 추상 메서드, 정적 상수만!
- this
    - 객체 자신을 명시적으로 지시하는 키워드
    - 이름이 겹치는 경우 사용
- super
    - 상위 클래스 인스턴스 지칭. 상위의 상위는 안됨

## 객체 지향 설계 5원칙 - SOLID

- 응집도 높이고, 결합도 낮추기 위한 원칙
    - 결합도 낮추면 모듈 간 의존성 줄어들어 재사용, 수정, 유지보수 용이
    - 응집도 높으면 하나의 책임에만 집중, 독립성 상승으로 ‘’
- SRP - 단일 책임 원칙
    - 하나의 클래스가 하나의 책임(역할)만 맡도록 분리
    - 사례
        - 특정 속성/메서드를 사용하지 않는 인스턴스
        - 분기문을 통해 인스턴스별로 다른 행위를 하도록 하는 메서드
- OCP - 개방 폐쇄 원칙
    - 확장에는 열려있고, 변화에는 닫혀있다
    - 사례
        - 클라이언트와 서버 사이에 인터페이스를 둠으로써, 변화가 발생하면 인터페이스를 수정함으로써 클라이언트의 변화를 최소화한다(변화에 닫힘). 또한, 새로운 서버를 사용하더라도 동일한 동작으로 처리할 수 있다.(확장에 열림)
        - JVM - 소스 코드는 운영체제 변화에 닫혀있고, 새로운 운영체제 등장해도 알맞는 JVM 설치하면 되므로 확장에 열려있음
        - ORM도 비슷하다는 생각. 다양한 데이터베이스를 개발자가 동일한 동작으로 다룰 수 있음!
- LSP - 리스코프 치환 원칙
    - 하위 클래스의 인스턴스는 상위 객체 참조 변수에 대입하여 상위 클래스의 인스턴스 역할을 수행할 수 있어야 한다.
    - 계층/조직도가 아닌 분류도! 추상화의 반대는 분류임을 기억하자.
- ISP - 인터페이스 분리 원칙
    - 특정 메서드를 사용하지 않을 때? 단일 책임 원칙에서는 클래스를 분리해야 한다.
    - 하지만 클래스를 여러 클래스로 쪼개는 것 외에도 인터페이스로 분리할 수 있다.
        - 즉 하나의 클래스를 다양한 역할을 수행하는 인터페이스로 표현하는 것!
    - 하지만 SRP가 더 좋다. 인터페이스는 최소로 사용하는 것이 좋기 때문.
        - ‘상위 클래스는 풍성할수록, 인터페이스는 작을수록 좋다’
            - 상위 클래스의 메서드를 가져다 쓰지 못하면 재사용률 감소…
            - 인터페이스는 관심 영역에서 최소로 다뤄야 겹치는 부분이 안 생김!
- DIP - 의존 역전 원칙
    - 구체적인 것이 추상적인 것에 의존해야 한다.
        - 자신보다 변하기 쉬운 것에 의존하면 안된다!
    - 추상적인 것이 구체적인 것에 의존하면 구체적인 것의 변화에 자주 영향받는다.
    - OCP에서 인터페이스를 두는 것과 비슷함!
- SoC - 관심사의 분리
    - 관심이 비슷한 것끼리는 하나의 객체로 모으고, 다른 것은 떨어트려 서로 영향 주지 않도록

## 06 스프링이 사랑한 디자인 패턴

- 다들 고민하는 내용 비슷. 해결 방법에도 패턴이 있는데, 이중 인정받는 사례들 정리!
- 어댑터 패턴
    - 공용 인터페이스를 추가하여 OCP 실현
- 프록시 패턴
- 데코레이터 패턴
- 싱글턴 패턴
    - 특정 대상에 대한 자원 소모 줄이기 위해 인스턴스 하나만 쓰기
    - 다양한 참조변수가 가리키기에, 속성 가지지 않도록
- 템플릿 메서드 패턴
    - 겹치는 부분 템플릿 메서드로 통일
    - 안겹치는 부분 중 무조건 달라지는 부분은 추상 메서드
    - 선택적으로 달라져야 하는 부분은 훅 메서드
- 팩터리 메서드 패턴
- 전략 패턴
    - 전략 생성 후 클라이언트가 컨텍스트에 주입
- 템플릿 콜백 패턴
- 스프링이 사랑한 다른 패턴들
    - 프론트 컨트롤러 패턴
    - MVC 패턴

- 별도 서적 통한 추가적인 공부 필요
