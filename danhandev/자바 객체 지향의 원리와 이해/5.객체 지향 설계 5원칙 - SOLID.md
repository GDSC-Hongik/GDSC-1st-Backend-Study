# 5. 객체 지향 설계 5원칙 - SOLID

SOLID는 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙의 앞 머리 알파벳을 따서 부르는 이름이다. 응집도는 높이고(High Conhesion), 결합도는 낮추라(Loose Coupling)는 좋은 소프트웨어 설계를 위한 고전 원칙을 객체 지향의 관점에서 재정립한 것이다.

```
▪️ 결합도는 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 
	모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
▪️ 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로,
	응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져
	재사용이나 기능의 수정, 유지보수가 용이하다.
```

SOLID는 소프트웨어에 녹여 내야 하는 개념이다. SOLID를 잘 녹여낸 소프트웨어는 이해하기 쉽고, 리팩토링과 유지보수가 수월할 뿐만 아니라 논리적으로 정연하다. SOLID는 객체 지향 4대 특성을 발판으로 하고 있으며, 디자인 패턴의 뼈대이며 스프링 프레임워크의 근간이다.

- SPR(단일 책임 원칙): 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- OCP(개방 폐쇄 원칙): 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
- LSP(리스코프 치환 원칙): 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
- ISP(인터페이스 분리 원칙): 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
- DIP(의존 역전 원칙): 자신보다 변하기 쉬운 것에 의존하지 마라.

## SRD - 단일 책임 원칙

- Single Resposibility Principle
- 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이다.
- 분기 처리를 위한 if 문은 단일 책임 원칙을 지키지 않을 경우 나타난다.

```java
package srp.bad;

public class 강아지 {
	final static Boolean 숫컷 = true;
	final static Boolean 암컷 = false;
	Boolean 성별;

	// 메서드 하나가 숫컷과 암컷의 행위를 모두 구현하려고 한다.
	// 단일 책임 원칙 위배
	void 소변보다() {
		if (this.성별 == 숫컷) {
			// 한쪽 다리를 들고 소변을 본다.
		} else {
			// 뒤다리 두 개로 앉은 자세로 소변을 본다.
		}
	}
}
```

```java
package srp.good;

// 단일 책임 원칙을 적용해 코드를 리팩토링 했다.
public class 숫컷강아지 extends 강아지 {
	void 소변보다() {
		// 한쪽 다리를 들고 소변을 본다.
	}
}

package srp.good;

public class 암컷강아지 extends 강아지 {
	void 소변보다() {
		// 뒤다리 두 개로 앉은 자세로 소변을 본다.
	}
}
```

## OCP - 개방 폐쇄 원칙

- Open Closed Principle
- 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
- JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MYSQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다. 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충 장치로 인해 변화에 영향을 받지 않는다. 바로 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀 있다는 것이다.

<img width="531" alt="image" src="https://user-images.githubusercontent.com/78093844/193795831-c30aa3f1-6746-4523-86e4-5091ad5ae5fd.png">

- 자바에도 개방 폐쇄 원칙이 적용돼 있다. 각 운영체제별 JVM과 목적 파일이 있기에 개발자는 다양한 구동 환경에 대해서는 걱정하지 않고 본인이 작업하고 있는 개발 PC에 설치된 JVM에서 구동되는 코드만 작성하면 된다. 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제 별 JVM은 확장에 열려 있는 구조가 되는 것이다. 개발자의 소스코드와 운영체제 별 JVM 사이에는 목적 파일이라고 하는 완충 장치가 있는 것이다.
- 개방 폐쇄 원칙을 지키면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성을 얻을 수 있다.

## LSP - 리스코프 치환 원칙
(5. 객체 지향 설계 5원칙): Write a summary.
- Liskov Substitution Principle
- 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
- 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
- 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 된다.
- 객체 지향의 상속 조건
    - 하위 클래스 is kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
    - 구현 클래스 is able of 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
- 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다.

## ISP - 인터페이스 분리 원칙

- Interface Segregation Principle
- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
- 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 잇다. 따라서 둘 중 하나를 선택해 설계할 수 있다. 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이다.
- 인터페이스 최소 주의 원칙
    - 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라
    - 상위 클래스는 풍성할 수록 좋고, 인터페이스는 작을수록 좋다.

<img width="672" alt="image" src="https://user-images.githubusercontent.com/78093844/193795931-81ca2a89-9af7-401d-9b53-fbe595f7d570.png">

## DIP - 의존 역전 원칙

- Dependency Inversion Principle
- 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다. 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 구체 클래스에 의존하지 마라

  → 자신보다 변하기 쉬운 것에 의존하지 마라

- 의존 역전 원칙은 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이다.

## 마무리

- SOLID는 객체 지향을 올바르게 프로그램에 녹여내기 위한 원칙이다. 따라서 객체 지향 4대 특성을 제대로 이해해야 SOLID를 제대로 이해하고 활용할 수 있다.
- SoC를 적용하면 자연스럽게 단일 책임 원칙, 인터페이스 분리 원칙, 개방 폐쇄 원칙에 도달하게 된다. SoC는 관심사의 분리(Separation Of Concerns)이다. 하나의 속성, 메서드, 클래스, 모듈, 패키지에는 하나의 관심사만 들어 있어야 한다는 것이다. 관심사가 다르고 변화의 시기가 다르면 분리해야 한다.
- SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아질 수 있다. 하지만 이렇게 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉬우며, 유지와 관리, 보수하기 쉬운 소스가 만들어진다.