## 스프링 부트와 JPA 활용

### 지연 로딩과 조회 성능 최적화

데이터 송수신시에 Entity 가 아닌 DTO 를 만들어서 사용.

장점
```
- 필요한 정보만 보낼 수 있게됨.
- 연관 관계를 Json 형태로 변환하는 과정에서 생기는 무한 참조 문제를 고려할 필요가 없어짐.
```

<br/>

하지만 LAZY 로딩 후 DTO 에 값을 설정하는 과정에서 N + 1 문제 발생 - 성능 저하 문제

> N + 1 문제란? <br/>
> 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 
> 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다.

이를 해결하기 위해서 fetch join 을 통해 연관 관계가 전부 join 된 테이블을 가져와 값을 설정한다.
  
마지막으로 쿼리 결과로 원하는 컬럼만을 가져오기 위해서 DTO 로 조회하는 방법을 사용할 수 있다. - 성능 최적화
> DTO 로 조회시 DTO 에 해당하는 컬럼만 조회함. <br/>
> 하지만 그 결과로 재사용성이 낮아짐.

<br/>

### 컬렉션 조회 최적화

앞의 내용은 위와 같다.

OneToMany 관계의 List 를 fetch join 을 통해 성능 최적화를 하면 페이징이 불가능해진다.
> One 을 기준으로 페이징을 하려고해도, 
> 쿼리문을 통해 만들어지는 컬럼의 수는 Many 의 컬럼의 수이기 때문에 예상과는 다르게 나온다. 

또한 컬렉션 fetch join 은 하나의 컬렉션에만 사용해야 한다. 
그렇지 않으면 데이터가 예상과는 다르게 나올 가능성이 크다.

<br/>

### fetch_size 설정을 통한 성능 최적화

앞서 말한 것과 같이 OneToMany 관계를 fetch join 을 통해 가져오면 페이징이 불가능해진다.
이를 극복하기 위한 대안책으로 나온 것이 아래의 설정이다.

> spring.jpa.properties.hibernate.default_batch_fetch_size
 
해당 설정을 하면, Many 를 조회할 때 In query 를 사용해서 설정한 size 만큼의 데이터를 한 번에 받아온다.

<br/>

### OSIV, 커맨드와 쿼리 분리

실시간 API 에서는 OSIV OFF <br/>
ADMIN과 같이 커넥션을 많이 사용하지 않는 곳에서는 OSIV ON

> 애플리케이션의 규모가 어느정도 커진다면, <br/>
> 핵심 비즈니스 로직(등록, 수정등)과 화면이나 API에 맞춘 서비스(주로 읽기 전용) 를 분리하는 것이 유지보수 관점에서 좋다.